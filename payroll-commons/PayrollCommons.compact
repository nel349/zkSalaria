pragma language_version >= 0.13.0;

module PayrollCommons {
  import CompactStandardLibrary;

  // Payment types for categorization
  export pure circuit PAYMENT_TYPE_SALARY(): Uint<8> { return 0 as Uint<8>; }
  export pure circuit PAYMENT_TYPE_ADVANCE(): Uint<8> { return 1 as Uint<8>; }
  export pure circuit PAYMENT_TYPE_BONUS(): Uint<8> { return 2 as Uint<8>; }

  // Disclosure permission types for selective disclosure
  export pure circuit PERMISSION_TYPE_INCOME_RANGE(): Uint<8> { return 0 as Uint<8>; }
  export pure circuit PERMISSION_TYPE_EMPLOYMENT(): Uint<8> { return 1 as Uint<8>; }
  export pure circuit PERMISSION_TYPE_CREDIT_SCORE(): Uint<8> { return 2 as Uint<8>; }
  export pure circuit PERMISSION_TYPE_AUDIT(): Uint<8> { return 3 as Uint<8>; }

  // Payment record for history tracking (used by ZKML credit scoring)
  // NOTE: Amounts are ENCRYPTED for privacy - employee decrypts locally for ZKML
  export struct PaymentRecord {
    timestamp: Uint<32>;           // When payment was made
    encrypted_amount: Bytes<32>;   // Payment amount (encrypted with employee key)
    company_id: Bytes<32>;         // Which company paid
    payment_type: Uint<8>;         // 0=salary, 1=advance, 2=bonus
  }

  // Disclosure authorization for selective disclosure (bank.compact pattern)
  // Stores shared encryption key on public ledger for both grantor and grantee
  export struct DisclosureAuthorization {
    grantor_id: Bytes<32>;              // Employee/company granting access
    grantee_id: Bytes<32>;              // Lender/landlord/auditor receiving access
    shared_encryption_key: Bytes<32>;   // Key stored on ledger for both parties
    threshold: Uint<64>;                // For range checks (e.g., "income >= $5k")
    created_at: Uint<32>;               // When authorization was created
    last_updated: Uint<32>;             // Last update timestamp
    permission_type: Uint<8>;           // 0=INCOME_RANGE, 1=EMPLOYMENT, 2=CREDIT_SCORE, 3=AUDIT
    expires_at: Uint<32>;               // 0=never expires, >0=expiration timestamp
  }

  // Recurring payment frequency constants
  export pure circuit FREQUENCY_WEEKLY(): Uint<8> { return 0 as Uint<8>; }
  export pure circuit FREQUENCY_BIWEEKLY(): Uint<8> { return 1 as Uint<8>; }
  export pure circuit FREQUENCY_MONTHLY(): Uint<8> { return 2 as Uint<8>; }

  // Recurring payment status constants
  export pure circuit RECURRING_STATUS_ACTIVE(): Uint<8> { return 0 as Uint<8>; }
  export pure circuit RECURRING_STATUS_PAUSED(): Uint<8> { return 1 as Uint<8>; }
  export pure circuit RECURRING_STATUS_CANCELLED(): Uint<8> { return 2 as Uint<8>; }

  // Employment status constants
  export pure circuit EMPLOYMENT_STATUS_INACTIVE(): Uint<8> { return 0 as Uint<8>; }
  export pure circuit EMPLOYMENT_STATUS_ACTIVE(): Uint<8> { return 1 as Uint<8>; }
  export pure circuit EMPLOYMENT_STATUS_TERMINATED(): Uint<8> { return 2 as Uint<8>; }
  export pure circuit EMPLOYMENT_STATUS_ON_LEAVE(): Uint<8> { return 3 as Uint<8>; }

  // Employment record for status tracking (independent of payment history)
  export struct EmploymentRecord {
    company_id: Bytes<32>;
    employee_id: Bytes<32>;
    status: Uint<8>;          // 0=inactive, 1=active, 2=terminated, 3=on_leave
    hire_date: Uint<32>;
    last_updated: Uint<32>;
  }

  // Recurring payment record for automated salary payments
  // Calendar configuration is stored; API calculates actual dates using Date libraries
  export struct RecurringPayment {
    recurring_payment_id: Bytes<32>;       // Unique ID
    company_id: Bytes<32>;                  // Which company
    employee_id: Bytes<32>;                 // Which employee
    encrypted_amount: Bytes<32>;            // Encrypted payment amount
    frequency: Uint<8>;                     // 0=weekly, 1=bi-weekly, 2=monthly
    start_date: Uint<32>;                   // When payments start
    end_date: Uint<32>;                     // When payments end (0=never)
    next_payment_date: Uint<32>;            // Next scheduled payment (API-calculated)

    // Calendar configuration (API uses these to calculate next_payment_date)
    payment_day_of_month_1: Uint<8>;       // For monthly: 1-31, biweekly: 1st day (e.g., 1), weekly: 0 (unused)
    payment_day_of_month_2: Uint<8>;       // For biweekly: 2nd day (e.g., 15), others: 0 (unused)
    payment_day_of_week: Uint<8>;          // For weekly: 0-6 (0=Sunday, 5=Friday), others: 0 (unused)

    status: Uint<8>;                        // 0=active, 1=paused, 2=cancelled
    created_at: Uint<32>;
    last_updated: Uint<32>;
  }

  // Helper to create a new payment record (with encrypted amount)
  export pure circuit create_payment_record(
    timestamp: Uint<32>,
    encrypted_amount: Bytes<32>,
    company_id: Bytes<32>,
    payment_type: Uint<8>
  ): PaymentRecord {
    return PaymentRecord {
      timestamp: timestamp,
      encrypted_amount: encrypted_amount,
      company_id: company_id,
      payment_type: payment_type
    };
  }

  // Helper to create empty payment history (for new employees)
  export pure circuit create_empty_history(): Vector<12, PaymentRecord> {
    const empty_record = PaymentRecord {
      timestamp: 0 as Uint<32>,
      encrypted_amount: pad(32, ""),  // Empty encrypted amount
      company_id: pad(32, ""),
      payment_type: 0 as Uint<8>
    };

    return [
      empty_record, empty_record, empty_record, empty_record,
      empty_record, empty_record, empty_record, empty_record,
      empty_record, empty_record, empty_record, empty_record
    ];
  }

  // Helper to append payment to history (shifts old records, adds new one)
  export pure circuit append_to_history(
    history: Vector<12, PaymentRecord>,
    new_record: PaymentRecord
  ): Vector<12, PaymentRecord> {
    // Shift all records left (oldest drops off)
    // Add new record at the end
    return [
      history[1],
      history[2],
      history[3],
      history[4],
      history[5],
      history[6],
      history[7],
      history[8],
      history[9],
      history[10],
      history[11],
      new_record
    ];
  }

  // Note: ML feature calculations (consistency score, average payment, variance, etc.)
  // are done LOCALLY using Python/EZKL, NOT in the smart contract.
  // The contract only stores payment history and verifies ZKML proofs.

  // Hash function for domain separation
  export pure circuit hash_employee_id(employee_id: Bytes<32>): Bytes<32> {
    return persistentHash<Vector<2, Bytes<32>>>([
      pad(32, "zksalaria:employee:"),
      employee_id
    ]);
  }

  export pure circuit hash_company_id(company_id: Bytes<32>): Bytes<32> {
    return persistentHash<Vector<2, Bytes<32>>>([
      pad(32, "zksalaria:company:"),
      company_id
    ]);
  }

  // Generate unique disclosure ID from grantor + grantee + permission type
  export pure circuit generate_disclosure_id(
    grantor_id: Bytes<32>,
    grantee_id: Bytes<32>,
    permission_type: Uint<8>
  ): Bytes<32> {
    return persistentHash<Vector<3, Bytes<32>>>([
      grantor_id,
      grantee_id,
      persistentHash<Uint<8>>(permission_type)
    ]);
  }

  // Generate shared encryption key for disclosure (bank.compact pattern)
  export pure circuit generate_shared_disclosure_key(
    grantor_id: Bytes<32>,
    grantee_id: Bytes<32>,
    permission_type: Uint<8>
  ): Bytes<32> {
    return persistentHash<Vector<4, Bytes<32>>>([
      pad(32, "zksalaria:disclosure:"),
      grantor_id,
      grantee_id,
      persistentHash<Uint<8>>(permission_type)
    ]);
  }

  // Generate unique employment record ID from company + employee
  export pure circuit generate_employment_record_id(
    company_id: Bytes<32>,
    employee_id: Bytes<32>
  ): Bytes<32> {
    return persistentHash<Vector<3, Bytes<32>>>([
      pad(32, "zksalaria:employment:"),
      company_id,
      employee_id
    ]);
  }

  // Generate unique recurring payment ID
  export pure circuit generate_recurring_payment_id(
    company_id: Bytes<32>,
    employee_id: Bytes<32>,
    timestamp: Uint<32>
  ): Bytes<32> {
    return persistentHash<Vector<4, Bytes<32>>>([
      pad(32, "zksalaria:recurring:"),
      company_id,
      employee_id,
      persistentHash<Uint<32>>(timestamp)
    ]);
  }

  // NOTE: Date calculations are now handled by API layer using JavaScript Date libraries
  // The contract just stores calendar configuration and validates API-provided dates

  // Legacy function - simple rolling schedule (kept for backward compatibility)
  export pure circuit calculate_next_payment_date(
    current_date: Uint<32>,
    frequency: Uint<8>
  ): Uint<32> {
    const days_to_add =
      (frequency == FREQUENCY_WEEKLY()) ? (7 as Uint<32>) :
      (frequency == FREQUENCY_BIWEEKLY()) ? (14 as Uint<32>) :
      (30 as Uint<32>); // FREQUENCY_MONTHLY

    // Assuming timestamps are in seconds: 1 day = 86400 seconds
    const seconds_to_add = (days_to_add * (86400 as Uint<32>)) as Uint<32>;
    return (current_date + seconds_to_add) as Uint<32>;
  }
}
