pragma language_version >= 0.13.0;

module PayrollCommons {
  import CompactStandardLibrary;

  // Payment types for categorization
  export pure circuit PAYMENT_TYPE_SALARY(): Uint<8> { return 0 as Uint<8>; }
  export pure circuit PAYMENT_TYPE_ADVANCE(): Uint<8> { return 1 as Uint<8>; }
  export pure circuit PAYMENT_TYPE_BONUS(): Uint<8> { return 2 as Uint<8>; }

  // Disclosure permission types for selective disclosure
  export pure circuit PERMISSION_TYPE_INCOME_RANGE(): Uint<8> { return 0 as Uint<8>; }
  export pure circuit PERMISSION_TYPE_EMPLOYMENT(): Uint<8> { return 1 as Uint<8>; }
  export pure circuit PERMISSION_TYPE_CREDIT_SCORE(): Uint<8> { return 2 as Uint<8>; }
  export pure circuit PERMISSION_TYPE_AUDIT(): Uint<8> { return 3 as Uint<8>; }

  // Payment record for history tracking (used by ZKML credit scoring)
  // NOTE: Amounts are ENCRYPTED for privacy - employee decrypts locally for ZKML
  export struct PaymentRecord {
    timestamp: Uint<32>;           // When payment was made
    encrypted_amount: Bytes<32>;   // Payment amount (encrypted with employee key)
    company_id: Bytes<32>;         // Which company paid
    payment_type: Uint<8>;         // 0=salary, 1=advance, 2=bonus
  }

  // Disclosure authorization for selective disclosure (bank.compact pattern)
  // Stores shared encryption key on public ledger for both grantor and grantee
  export struct DisclosureAuthorization {
    grantor_id: Bytes<32>;              // Employee/company granting access
    grantee_id: Bytes<32>;              // Lender/landlord/auditor receiving access
    shared_encryption_key: Bytes<32>;   // Key stored on ledger for both parties
    threshold: Uint<64>;                // For range checks (e.g., "income >= $5k")
    created_at: Uint<32>;               // When authorization was created
    last_updated: Uint<32>;             // Last update timestamp
    permission_type: Uint<8>;           // 0=INCOME_RANGE, 1=EMPLOYMENT, 2=CREDIT_SCORE, 3=AUDIT
    expires_at: Uint<32>;               // 0=never expires, >0=expiration timestamp
  }

  // Employment status constants
  export pure circuit EMPLOYMENT_STATUS_INACTIVE(): Uint<8> { return 0 as Uint<8>; }
  export pure circuit EMPLOYMENT_STATUS_ACTIVE(): Uint<8> { return 1 as Uint<8>; }
  export pure circuit EMPLOYMENT_STATUS_TERMINATED(): Uint<8> { return 2 as Uint<8>; }
  export pure circuit EMPLOYMENT_STATUS_ON_LEAVE(): Uint<8> { return 3 as Uint<8>; }

  // Employment record for status tracking (independent of payment history)
  export struct EmploymentRecord {
    company_id: Bytes<32>;
    employee_id: Bytes<32>;
    status: Uint<8>;          // 0=inactive, 1=active, 2=terminated, 3=on_leave
    hire_date: Uint<32>;
    last_updated: Uint<32>;
  }

  // Helper to create a new payment record (with encrypted amount)
  export pure circuit create_payment_record(
    timestamp: Uint<32>,
    encrypted_amount: Bytes<32>,
    company_id: Bytes<32>,
    payment_type: Uint<8>
  ): PaymentRecord {
    return PaymentRecord {
      timestamp: timestamp,
      encrypted_amount: encrypted_amount,
      company_id: company_id,
      payment_type: payment_type
    };
  }

  // Helper to create empty payment history (for new employees)
  export pure circuit create_empty_history(): Vector<12, PaymentRecord> {
    const empty_record = PaymentRecord {
      timestamp: 0 as Uint<32>,
      encrypted_amount: pad(32, ""),  // Empty encrypted amount
      company_id: pad(32, ""),
      payment_type: 0 as Uint<8>
    };

    return [
      empty_record, empty_record, empty_record, empty_record,
      empty_record, empty_record, empty_record, empty_record,
      empty_record, empty_record, empty_record, empty_record
    ];
  }

  // Helper to append payment to history (shifts old records, adds new one)
  export pure circuit append_to_history(
    history: Vector<12, PaymentRecord>,
    new_record: PaymentRecord
  ): Vector<12, PaymentRecord> {
    // Shift all records left (oldest drops off)
    // Add new record at the end
    return [
      history[1],
      history[2],
      history[3],
      history[4],
      history[5],
      history[6],
      history[7],
      history[8],
      history[9],
      history[10],
      history[11],
      new_record
    ];
  }

  // Note: ML feature calculations (consistency score, average payment, variance, etc.)
  // are done LOCALLY using Python/EZKL, NOT in the smart contract.
  // The contract only stores payment history and verifies ZKML proofs.

  // Hash function for domain separation
  export pure circuit hash_employee_id(employee_id: Bytes<32>): Bytes<32> {
    return persistentHash<Vector<2, Bytes<32>>>([
      pad(32, "zksalaria:employee:"),
      employee_id
    ]);
  }

  export pure circuit hash_company_id(company_id: Bytes<32>): Bytes<32> {
    return persistentHash<Vector<2, Bytes<32>>>([
      pad(32, "zksalaria:company:"),
      company_id
    ]);
  }

  // Generate unique disclosure ID from grantor + grantee + permission type
  export pure circuit generate_disclosure_id(
    grantor_id: Bytes<32>,
    grantee_id: Bytes<32>,
    permission_type: Uint<8>
  ): Bytes<32> {
    return persistentHash<Vector<3, Bytes<32>>>([
      grantor_id,
      grantee_id,
      persistentHash<Uint<8>>(permission_type)
    ]);
  }

  // Generate shared encryption key for disclosure (bank.compact pattern)
  export pure circuit generate_shared_disclosure_key(
    grantor_id: Bytes<32>,
    grantee_id: Bytes<32>,
    permission_type: Uint<8>
  ): Bytes<32> {
    return persistentHash<Vector<4, Bytes<32>>>([
      pad(32, "zksalaria:disclosure:"),
      grantor_id,
      grantee_id,
      persistentHash<Uint<8>>(permission_type)
    ]);
  }

  // Generate unique employment record ID from company + employee
  export pure circuit generate_employment_record_id(
    company_id: Bytes<32>,
    employee_id: Bytes<32>
  ): Bytes<32> {
    return persistentHash<Vector<3, Bytes<32>>>([
      pad(32, "zksalaria:employment:"),
      company_id,
      employee_id
    ]);
  }
}
