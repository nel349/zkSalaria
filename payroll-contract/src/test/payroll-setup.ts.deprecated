import { type Ledger, ledger } from '../managed/payroll/contract/index.cjs';
import { Contract, type PayrollPrivateState, createPayrollPrivateState, payrollWitnesses, PaymentRecord } from '../index.js';
import {
  CircuitContext,
  constructorContext,
  sampleContractAddress,
  QueryContext,
} from '@midnight-ntwrk/compact-runtime';

// Test setup class for payroll contract (one contract per company)
export class PayrollTestSetup {
  private contract: Contract<PayrollPrivateState, typeof payrollWitnesses>;
  private turnContext: CircuitContext<PayrollPrivateState>;
  private contractAddress: string;
  private companyId: string;
  private companyName: string;

  // Manual balance tracking (since actual balances are encrypted on ledger)
  private companyBalanceTracker: bigint = 0n;
  private employeeBalanceTrackers: Map<string, bigint> = new Map();

  constructor(
    companyId: string,
    companyName: string,
    initNonce: string = '0'.repeat(64)
  ) {
    this.companyId = companyId;
    this.companyName = companyName;

    // Initialize payroll contract with witnesses
    this.contract = new Contract(payrollWitnesses);
    this.contractAddress = sampleContractAddress();

    // Initialize with empty payroll private state
    const initialPrivateState = createPayrollPrivateState();

    // Convert parameters to Uint8Array for constructor
    const nonceBytes = this.hexToBytes32(initNonce);
    const companyIdBytes = this.stringToBytes32(companyId);
    const companyNameBytes = this.stringToBytes64(companyName);

    // Get initial state from contract
    // Note: Constructor now takes (initNonce, companyId, companyName)
    const { currentPrivateState, currentContractState, currentZswapLocalState} = this.contract.initialState(
      constructorContext(initialPrivateState, initNonce),
      nonceBytes,
      companyIdBytes,
      companyNameBytes
    );

    // Set up turn context
    this.turnContext = {
      currentPrivateState,
      currentZswapLocalState,
      originalState: currentContractState,
      transactionContext: new QueryContext(currentContractState.data, sampleContractAddress()),
    };

    console.log(`üíº Payroll contract initialized for company: ${companyName} (${companyId})`);
  }

  // Helper to convert string to Bytes<32>
  private stringToBytes32(str: string): Uint8Array {
    const bytes = new Uint8Array(32);
    const encoder = new TextEncoder();
    const encoded = encoder.encode(str);
    bytes.set(encoded.slice(0, Math.min(encoded.length, 32)));
    return bytes;
  }

  // Helper to convert string to Bytes<64>
  private stringToBytes64(str: string): Uint8Array {
    const bytes = new Uint8Array(64);
    const encoder = new TextEncoder();
    const encoded = encoder.encode(str);
    bytes.set(encoded.slice(0, Math.min(encoded.length, 64)));
    return bytes;
  }

  // Helper to convert hex string to Bytes<32>
  private hexToBytes32(hex: string): Uint8Array {
    const bytes = new Uint8Array(32);
    for (let i = 0; i < Math.min(hex.length, 64); i += 2) {
      bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
    }
    return bytes;
  }

  // Helper to update state and get ledger
  private updateStateAndGetLedger(circuitResults: any): Ledger {
    this.turnContext = circuitResults.context;
    return ledger(this.turnContext.transactionContext.state);
  }

  // Test method: Add employee (no registration needed - company created in constructor)
  addEmployee(employeeId: string): Ledger {
    console.log(`üë§ Adding employee ${employeeId} to ${this.companyName}`);

    const employeeIdBytes = this.stringToBytes32(employeeId);

    // Initialize employee balance tracker
    this.employeeBalanceTrackers.set(employeeId, 0n);

    const results = this.contract.impureCircuits.add_employee(this.turnContext, employeeIdBytes);
    return this.updateStateAndGetLedger(results);
  }

  // Test method: Mint tokens (for testing)
  mintTokens(amount: bigint): Ledger {
    console.log(`ü™ô Minting ${amount} tokens for testing`);

    const results = this.contract.impureCircuits.mint_tokens(this.turnContext, amount);
    return this.updateStateAndGetLedger(results);
  }

  // Test method: Deposit company funds
  depositCompanyFunds(amount: bigint): Ledger {
    console.log(`üí∞ ${this.companyName} depositing ${amount} tokens`);

    // Track company balance increase
    this.companyBalanceTracker += amount;

    const results = this.contract.impureCircuits.deposit_company_funds(this.turnContext, amount);
    return this.updateStateAndGetLedger(results);
  }

  // Test method: Pay employee
  payEmployee(employeeId: string, amount: bigint): Ledger {
    console.log(`üí∏ ${this.companyName} paying employee ${employeeId}: ${amount} tokens`);

    const employeeIdBytes = this.stringToBytes32(employeeId);

    // Track balance transfer: company -> employee
    this.companyBalanceTracker -= amount;
    const currentEmployeeBalance = this.employeeBalanceTrackers.get(employeeId) || 0n;
    this.employeeBalanceTrackers.set(employeeId, currentEmployeeBalance + amount);

    const results = this.contract.impureCircuits.pay_employee(this.turnContext, employeeIdBytes, amount);
    return this.updateStateAndGetLedger(results);
  }

  // Test method: Withdraw employee salary
  withdrawEmployeeSalary(employeeId: string, amount: bigint): Ledger {
    console.log(`üíµ Employee ${employeeId} withdrawing ${amount} tokens`);

    const employeeIdBytes = this.stringToBytes32(employeeId);

    // Track employee balance decrease
    const currentEmployeeBalance = this.employeeBalanceTrackers.get(employeeId) || 0n;
    this.employeeBalanceTrackers.set(employeeId, currentEmployeeBalance - amount);

    const results = this.contract.impureCircuits.withdraw_employee_salary(this.turnContext, employeeIdBytes, amount);
    return this.updateStateAndGetLedger(results);
  }

  // Test method: Update timestamp
  updateTimestamp(newTimestamp: number): Ledger {
    console.log(`‚è∞ Updating timestamp to ${newTimestamp}`);

    const results = this.contract.impureCircuits.update_timestamp(this.turnContext, BigInt(newTimestamp));
    return this.updateStateAndGetLedger(results);
  }

  // Getter methods for state inspection
  getLedgerState(): Ledger {
    return ledger(this.turnContext.transactionContext.state);
  }

  getPrivateState(): PayrollPrivateState {
    return this.turnContext.currentPrivateState;
  }

  // Helper: Get current timestamp
  getCurrentTimestamp(): number {
    return Number(this.getLedgerState().current_timestamp);
  }

  // Helper: Get total companies (always 1 for single-company-per-contract architecture)
  getTotalCompanies(): bigint {
    return 1n; // Each contract represents exactly one company
  }

  // Helper: Get total employees
  getTotalEmployees(): bigint {
    return this.getLedgerState().total_employees;
  }

  // Helper: Get total payments
  getTotalPayments(): bigint {
    return this.getLedgerState().total_payments;
  }

  // Helper: Get total supply
  getTotalSupply(): bigint {
    return this.getLedgerState().total_supply;
  }

  // Helper: Get token reserve balance (actual tokens in reserve)
  getTokenReserveBalance(): bigint {
    const ledgerState = this.getLedgerState();
    // QualifiedCoinInfo has a 'value' field with the token amount
    return ledgerState.token_reserve.value;
  }

  // Helper: Get expected company balance (tracked through transaction flow)
  getExpectedCompanyBalance(): bigint {
    return this.companyBalanceTracker;
  }

  // Helper: Get expected employee balance (tracked through transaction flow)
  getExpectedEmployeeBalance(employeeId: string): bigint {
    return this.employeeBalanceTrackers.get(employeeId) || 0n;
  }

  // NOTE: Balances are now ENCRYPTED on public ledger (bank contract pattern)
  // Cannot read balances directly from witnesses - they are encrypted with participant keys
  // In production, you would need the participant's encryption key to decrypt balances
  // For testing, we track balances through transaction flow (deposits, payments, withdrawals)

  // Helper: Get employee payment history (from PUBLIC LEDGER - not witness)
  // NOTE: Following bank.compact pattern - payment history stored on ledger
  getEmployeePaymentHistory(employeeId: string): PaymentRecord[] {
    const ledgerState = this.getLedgerState();
    const employeeIdBytes = this.stringToBytes32(employeeId);

    // The Map from Compact Runtime has methods: member(), lookup(), size, isEmpty
    const historyMap = ledgerState.employee_payment_history as any;

    // Check if employee has payment history using member() method
    if (historyMap.member(employeeIdBytes)) {
      // Use lookup() method to get the history
      const history = historyMap.lookup(employeeIdBytes);
      return history as PaymentRecord[];
    }

    return [];
  }

  // Helper: Decrypt payment amount from encrypted_amount field
  // Uses balance_mappings ledger to decrypt (bank.compact pattern)
  decryptPaymentAmount(encryptedAmount: Uint8Array): bigint | null {
    const ledgerState = this.getLedgerState();
    const balanceMappings = ledgerState.balance_mappings as any;

    // Check if this encrypted amount has a mapping
    if (balanceMappings.member(encryptedAmount)) {
      return balanceMappings.lookup(encryptedAmount) as bigint;
    }

    return null; // Cannot decrypt - no mapping found
  }

  // Helper: Get ACTUAL employee balance from ledger (decrypt from encrypted balance)
  // Uses encrypted_employee_balances + balance_mappings to decrypt
  getActualEmployeeBalance(employeeId: string): bigint | null {
    const ledgerState = this.getLedgerState();
    const employeeIdBytes = this.stringToBytes32(employeeId);

    const encryptedBalances = ledgerState.encrypted_employee_balances as any;
    const balanceMappings = ledgerState.balance_mappings as any;

    // Look up employee's encrypted balance
    if (!encryptedBalances.member(employeeIdBytes)) {
      return null; // Employee has no balance entry
    }

    const encryptedBalance = encryptedBalances.lookup(employeeIdBytes);

    // Decrypt using balance_mappings
    if (!balanceMappings.member(encryptedBalance)) {
      return null; // Cannot decrypt - no mapping found
    }

    return balanceMappings.lookup(encryptedBalance) as bigint;
  }

  // Helper: Get company balance (token reserve = company balance)
  getActualCompanyBalance(): bigint {
    return this.getTokenReserveBalance();
  }

  // Debug helper: Print current payroll state
  printPayrollState(): void {
    console.log('\nüìä Payroll System State:');
    console.log('‚îú‚îÄ Total Companies:', this.getTotalCompanies().toString());
    console.log('‚îú‚îÄ Total Employees:', this.getTotalEmployees().toString());
    console.log('‚îú‚îÄ Total Payments:', this.getTotalPayments().toString());
    console.log('‚îú‚îÄ Total Supply:', this.getTotalSupply().toString());
    console.log('‚îî‚îÄ Current Timestamp:', this.getCurrentTimestamp());
    console.log('');
  }

  // ========================================
  // EMPLOYMENT VERIFICATION METHODS
  // ========================================

  // Test method: Grant employment disclosure
  grantEmploymentDisclosure(employeeId: string, verifierId: string, expiresIn: number): Ledger {
    console.log(`üîê Employee ${employeeId} granting employment disclosure to ${verifierId} for company ${this.companyId}`);

    const employeeIdBytes = this.stringToBytes32(employeeId);
    const verifierIdBytes = this.stringToBytes32(verifierId);

    const results = this.contract.impureCircuits.grant_employment_disclosure(
      this.turnContext,
      employeeIdBytes,
      verifierIdBytes,
      BigInt(expiresIn)
    );
    return this.updateStateAndGetLedger(results);
  }

  // Test method: Update employment status
  updateEmploymentStatus(employeeId: string, newStatus: number): Ledger {
    console.log(`üìù Company ${this.companyId} updating employment status for ${employeeId} to ${newStatus}`);

    const employeeIdBytes = this.stringToBytes32(employeeId);

    const results = this.contract.impureCircuits.update_employment_status(
      this.turnContext,
      employeeIdBytes,
      BigInt(newStatus)
    );
    return this.updateStateAndGetLedger(results);
  }

  // Test method: Verify employment
  verifyEmployment(employeeId: string, verifierId: string): Uint8Array {
    console.log(`‚úÖ Verifier ${verifierId} checking employment of ${employeeId} at ${this.companyId}`);

    const employeeIdBytes = this.stringToBytes32(employeeId);
    const verifierIdBytes = this.stringToBytes32(verifierId);

    const results = this.contract.impureCircuits.verify_employment(
      this.turnContext,
      employeeIdBytes,
      verifierIdBytes
    );

    // Update state from circuit execution
    this.turnContext = results.context;

    // Return the result (Bytes<1>: 0x01 = employed, 0x00 = not employed)
    return results.result;
  }

  // Test method: Revoke disclosure
  revokeDisclosure(grantorId: string, granteeId: string, permissionType: number): Ledger {
    console.log(`üö´ ${grantorId} revoking disclosure for ${granteeId}`);

    const grantorIdBytes = this.stringToBytes32(grantorId);
    const granteeIdBytes = this.stringToBytes32(granteeId);

    const results = this.contract.impureCircuits.revoke_disclosure(
      this.turnContext,
      grantorIdBytes,
      granteeIdBytes,
      BigInt(permissionType)
    );

    return this.updateStateAndGetLedger(results);
  }
}
