pragma language_version >= 0.13.0;

import CompactStandardLibrary;
import "../../payroll-commons/PayrollCommons" prefix PC_;

// zkSalaria - Private Payroll System
// Privacy-preserving payroll with real token operations

export { CoinInfo };

// ========================================
// LEDGER STATE (Public)
// ========================================
// NOTE: One contract instance per company (battleship pattern)

// Company identity (this contract represents ONE company)
export ledger company_id: Bytes<32>;         // This company's ID
export ledger company_name: Bytes<64>;       // This company's name

// Employee registry (hash commitments only - PUBLIC)
export ledger employee_accounts: Map<Bytes<32>, Bytes<32>>;  // employee_id -> hash commitment

// ENCRYPTED BALANCE SYSTEM (Bank Contract Pattern)
// Employee balances encrypted on ledger, only decryptable with proper keys
export ledger encrypted_employee_balances: Map<Bytes<32>, Bytes<32>>; // employee_id -> encrypted_balance
export ledger balance_mappings: Map<Bytes<32>, Uint<64>>;             // encrypted_balance -> actual_amount

// Token system state (PUBLIC)
export ledger nonce: Bytes<32>;
export ledger token_counter: Counter;
export ledger total_supply: Uint<64>;                         // Total tokens in this company's contract
export ledger token_reserve: QualifiedCoinInfo;                // This company's token reserve

// Counters for metrics
export ledger total_employees: Counter;
export ledger total_payments: Counter;

// System state
export ledger current_timestamp: Uint<32>;

// Payment history on ledger (for ZKML credit scoring)
// Stored on public ledger so company can write when paying employee
// NOTE: Following bank.compact pattern - history on ledger, not witnesses
export ledger employee_payment_history: Map<Bytes<32>, Vector<12, PC_PaymentRecord>>;

// Selective disclosure system (Bank Contract Pattern)
// Stores disclosure authorizations and shared keys on public ledger
export ledger disclosure_authorizations: Map<Bytes<32>, PC_DisclosureAuthorization>; // disclosure_id -> authorization
export ledger shared_payment_history: Map<Bytes<32>, Bytes<32>>;  // disclosure_id -> encrypted_history

// Employment status tracking (independent of payment history)
// Key: hash(company_id + employee_id)
export ledger employment_records: Map<Bytes<32>, PC_EmploymentRecord>;

// Recurring payment schedules
// Key: recurring_payment_id and Value: PC_RecurringPayment
export ledger recurring_payments: Map<Bytes<32>, PC_RecurringPayment>;
// Helper map: employee_id -> recurring_payment_id (for easy lookup in tests)
export ledger recurring_payment_by_employee: Map<Bytes<32>, Bytes<32>>;

constructor(
  initNonce: Bytes<32>,
  companyId: Bytes<32>,
  companyName: Bytes<64>,
  initialTimestamp: Uint<32>  // Unix timestamp in seconds (e.g., Math.floor(Date.now() / 1000))
) {
  nonce = disclose(initNonce);
  company_id = disclose(companyId);
  company_name = disclose(companyName);
  current_timestamp = disclose(initialTimestamp);
  total_supply = 0 as Uint<64>;
}

// ========================================
// ENCRYPTION HELPERS (Bank Contract Pattern)
// ========================================

// Encrypt balance with participant's key (hash-based encryption)
pure circuit encrypt_balance(balance: Uint<64>, encryption_key: Bytes<32>): Bytes<32> {
  // Hash balance with key for deterministic encryption
  // In production, would use AES or similar
  const encrypted = persistentHash<Vector<2, Bytes<32>>>([
    persistentHash<Uint<64>>(balance),
    encryption_key
  ]);
  return encrypted;
}

// Generate encryption key for participant (derived from participant ID)
// NOTE: No PIN needed - authentication happens at API layer (company/employee login)
// Smart contract only verifies: company/employee exists on ledger
pure circuit generate_balance_key(participant_id: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<2, Bytes<32>>>([
    pad(32, "zksalaria:balance:"),
    disclose(participant_id)  // Disclosed since IDs are already public on ledger
  ]);
}

// ========================================
// TOKEN OPERATIONS (Testing/Bootstrap)
// ========================================

// Mint tokens for testing (will be replaced with real token deposits later)
export circuit mint_tokens(amount: Uint<64>): [] {
  assert(disclose(amount) > 0 as Uint<64>, "Amount must be positive");

  token_counter.increment(1);
  const newNonce = evolveNonce(token_counter, nonce);

  mintToken(
    pad(32, "zksalaria_payroll_token"),
    disclose(amount),
    newNonce,
    left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey())
  );

  total_supply = (total_supply + disclose(amount)) as Uint<64>;
  nonce = newNonce;
}

// ========================================
// COMPANY OPERATIONS
// ========================================
// NOTE: No registration needed - company created in constructor

// Company deposits funds to treasury (mints payroll tokens)
// NOTE: Only this contract's company can deposit (enforced at API layer)
export circuit deposit_company_funds(
  amount: Uint<64>
): [] {
  assert(disclose(amount) > 0 as Uint<64>, "Amount must be positive");

  // Evolve nonce for unique token operation
  token_counter.increment(1);
  const newNonce = evolveNonce(token_counter, nonce);

  // Mint payroll tokens and send to contract (real token creation)
  const minted_coin = mintToken(
    pad(32, "zksalaria_payroll_token"),
    disclose(amount),  // Uint<64> - CoinInfo.value is actually Uint<128> but mintToken parameter is Uint<64>
    newNonce,
    right<ZswapCoinPublicKey, ContractAddress>(kernel.self())  // Send to contract itself
  );

  // Receive the minted coin into contract
  receive(disclose(minted_coin));

  // Merge with existing reserve or create new reserve
  if (total_supply > 0 as Uint<64>) {
    // Merge new coin with existing reserve
    const merged_coin = mergeCoinImmediate(token_reserve, disclose(minted_coin));
    token_reserve.writeCoin(merged_coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));
  } else {
    // First deposit - create new reserve
    token_reserve.writeCoin(disclose(minted_coin), right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));
  }

  // Update total supply (company balance = token_reserve value)
  total_supply = (total_supply + disclose(amount)) as Uint<64>;
  nonce = newNonce;
}

// ========================================
// EMPLOYEE OPERATIONS
// ========================================

// Register a new employee
// NOTE: Only this contract's company can add employees (enforced at API layer)
export circuit add_employee(
  employee_id: Bytes<32>
): [] {
  assert(!employee_accounts.member(disclose(employee_id)), "Employee already exists");

  const employee_hash = persistentHash<Vector<2, Bytes<32>>>([
    pad(32, "zksalaria:employee:"),
    employee_id
  ]);

  employee_accounts.insert(disclose(employee_id), disclose(employee_hash));
  total_employees.increment(1);

  // Initialize empty payment history on ledger for new employee
  const empty_history = PC_create_empty_history();
  employee_payment_history.insert(disclose(employee_id), empty_history);

  // Create employment record with active status
  const employment_record_id = PC_generate_employment_record_id(
    disclose(company_id),
    disclose(employee_id)
  );

  const employment_record = PC_EmploymentRecord {
    company_id: disclose(company_id),
    employee_id: disclose(employee_id),
    status: PC_EMPLOYMENT_STATUS_ACTIVE(),
    hire_date: current_timestamp,
    last_updated: current_timestamp
  };

  employment_records.insert(employment_record_id, employment_record);
}

// Employee withdraws earned salary (burns payroll tokens)
// NOTE: Balance now ENCRYPTED on ledger (bank contract pattern)
export circuit withdraw_employee_salary(
  employee_id: Bytes<32>,
  amount: Uint<64>
): [] {
  // Verify employee exists on public ledger
  assert(employee_accounts.member(disclose(employee_id)), "Employee not found");
  assert(disclose(amount) > 0 as Uint<64>, "Amount must be positive");

  // Generate encryption key for employee
  const employee_key = generate_balance_key(employee_id);

  // Get current encrypted balance
  assert(encrypted_employee_balances.member(disclose(employee_id)), "Employee has no balance");
  const current_encrypted = encrypted_employee_balances.lookup(disclose(employee_id));

  // Decrypt to get actual amount
  const current_balance = balance_mappings.lookup(current_encrypted);

  // Verify sufficient balance
  assert(current_balance >= disclose(amount), "Insufficient balance");

  // Deduct withdrawal amount
  const new_balance = (current_balance - disclose(amount)) as Uint<64>;

  // Encrypt new balance
  const new_encrypted = encrypt_balance(new_balance, employee_key);

  // Update encrypted balance on ledger
  encrypted_employee_balances.insert(disclose(employee_id), new_encrypted);

  // Update balance mapping for decryption
  balance_mappings.insert(new_encrypted, new_balance);

  // Send payroll tokens from contract reserve to employee (REAL token transfer)
  assert(total_supply >= disclose(amount), "Insufficient token reserve");

  // Send tokens to employee (ownPublicKey = caller = employee)
  const send_result = send(
    token_reserve,
    left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()),
    disclose(amount) as Uint<128>
  );

  // Update reserve with change
  if (send_result.change.is_some) {
    token_reserve.writeCoin(send_result.change.value, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));
  }
  // Note: If no change, reserve is fully spent but will be replenished on next deposit

  // Decrease total supply (public - aggregate metric)
  total_supply = (total_supply - disclose(amount)) as Uint<64>;
}

// ========================================
// PAYMENT OPERATIONS
// ========================================

// Process single salary payment (company -> employee)
// NOTE: Employee balances ENCRYPTED on ledger, company balance = token_reserve
// NOTE: Only this contract's company can pay (enforced at API layer)
export circuit pay_employee(
  employee_id: Bytes<32>,
  salary_amount: Uint<64>
): [] {
  // Verify employee exists
  assert(employee_accounts.member(disclose(employee_id)), "Employee not found");
  assert(disclose(salary_amount) > 0 as Uint<64>, "Amount must be positive");

  // Verify company has sufficient balance in token reserve
  assert(total_supply >= disclose(salary_amount), "Insufficient company funds");

  // Generate encryption key for employee
  const employee_key = generate_balance_key(employee_id);

  // Decrypt employee balance (or initialize to 0 if new)
  const employee_encrypted = encrypted_employee_balances.member(disclose(employee_id)) ?
    encrypted_employee_balances.lookup(disclose(employee_id)) : encrypt_balance(0 as Uint<64>, employee_key);
  const employee_balance = balance_mappings.member(employee_encrypted) ?
    balance_mappings.lookup(employee_encrypted) : 0 as Uint<64>;

  // Add payment to employee balance
  const new_employee_balance = (employee_balance + disclose(salary_amount)) as Uint<64>;

  // Re-encrypt employee balance
  const new_employee_encrypted = encrypt_balance(new_employee_balance, employee_key);

  // Update encrypted employee balance on ledger
  encrypted_employee_balances.insert(disclose(employee_id), new_employee_encrypted);

  // Update balance mapping for decryption
  balance_mappings.insert(new_employee_encrypted, new_employee_balance);

  // Read employee payment history from LEDGER (for ZKML tracking)
  // NOTE: Now stored on ledger so company can update it when paying
  const history = employee_payment_history.lookup(disclose(employee_id));

  // Encrypt payment amount with employee's key (privacy - only employee can decrypt for ZKML)
  const encrypted_payment_amount = encrypt_balance(disclose(salary_amount), employee_key);

  // Add encrypted amount to balance_mappings for decryption (bank.compact pattern)
  // This allows employee (and authorized parties with disclosure) to decrypt amounts
  balance_mappings.insert(encrypted_payment_amount, disclose(salary_amount));

  // Create new payment record (with ENCRYPTED amount for privacy)
  const new_payment = PC_create_payment_record(
    current_timestamp,
    encrypted_payment_amount,  // Encrypted amount (not plain text!)
    company_id,  // This contract's company ID (from ledger)
    PC_PAYMENT_TYPE_SALARY()
  );

  // Append to history (shifts old records out)
  const updated_history = PC_append_to_history(history, new_payment);

  // Save updated history to LEDGER (ZKML data, accessible to employee for credit scoring)
  employee_payment_history.insert(disclose(employee_id), updated_history);

  // Only public update: increment payment counter (aggregate only)
  total_payments.increment(1);
}

// TODO: Add batch payment processing (requires understanding Compact loop constraints)
// export circuit batch_pay_employees(...)

// ========================================
// SELECTIVE DISCLOSURE CIRCUITS
// ========================================

// Grant income disclosure to lender/verifier
// Employee grants permission for lender to verify income using ZKML
// NOTE: Actual verification happens OFF-CHAIN with ZK proofs (EZKL)
// This circuit just stores the authorization on ledger
export circuit grant_income_disclosure(
  employee_id: Bytes<32>,
  lender_id: Bytes<32>,
  min_threshold: Uint<64>,
  expires_in: Uint<32>  // 0 = never expires, >0 = seconds until expiration
): [] {
  // Verify employee exists on public ledger
  assert(employee_accounts.member(disclose(employee_id)), "Employee not found");

  // Generate unique disclosure ID
  const permission_type = PC_PERMISSION_TYPE_INCOME_RANGE();
  const disclosure_id = PC_generate_disclosure_id(
    disclose(employee_id),
    disclose(lender_id),
    permission_type
  );

  // Generate shared encryption key (stored on ledger for both parties)
  const shared_key = PC_generate_shared_disclosure_key(
    disclose(employee_id),
    disclose(lender_id),
    permission_type
  );

  // Calculate expiration timestamp (disclose expires_in as it's not sensitive)
  const expiration = (disclose(expires_in) == 0 as Uint<32>) ?
    0 as Uint<32> :
    (current_timestamp + disclose(expires_in)) as Uint<32>;

  // Create disclosure authorization
  const authorization = PC_DisclosureAuthorization {
    grantor_id: disclose(employee_id),
    grantee_id: disclose(lender_id),
    shared_encryption_key: shared_key,
    threshold: disclose(min_threshold),
    created_at: current_timestamp,
    last_updated: current_timestamp,
    permission_type: permission_type,
    expires_at: expiration
  };

  // Store authorization on public ledger
  disclosure_authorizations.insert(disclosure_id, authorization);

  // Read employee payment history from ledger
  const payment_history = employee_payment_history.lookup(disclose(employee_id));

  // Encrypt payment history with shared key for grantee access
  const history_hash = persistentHash<Vector<2, Bytes<32>>>([
    persistentHash<Vector<12, PC_PaymentRecord>>(payment_history),
    shared_key
  ]);

  // Store shared encrypted history on ledger
  shared_payment_history.insert(disclosure_id, history_hash);
}

// Grant employment disclosure to verifier (landlord, background check, etc.)
// Stores authorization for verifier to verify employment status using ZKML
// NOTE: Actual verification happens OFF-CHAIN with ZK proofs (EZKL)
// NOTE: Employee grants disclosure for THIS contract's company (company_id from ledger)
export circuit grant_employment_disclosure(
  employee_id: Bytes<32>,
  verifier_id: Bytes<32>,
  expires_in: Uint<32>
): [] {
  // Verify employee exists
  assert(employee_accounts.member(disclose(employee_id)), "Employee not found");

  // Generate unique disclosure ID
  const permission_type = PC_PERMISSION_TYPE_EMPLOYMENT();
  const disclosure_id = PC_generate_disclosure_id(
    disclose(employee_id),
    disclose(verifier_id),
    permission_type
  );

  // Generate shared encryption key
  const shared_key = PC_generate_shared_disclosure_key(
    disclose(employee_id),
    disclose(verifier_id),
    permission_type
  );

  // Calculate expiration timestamp
  const expiration = (disclose(expires_in) == 0 as Uint<32>) ?
    0 as Uint<32> :
    (current_timestamp + disclose(expires_in)) as Uint<32>;

  // Create authorization (company_id stored separately if needed)
  const authorization = PC_DisclosureAuthorization {
    grantor_id: disclose(employee_id),
    grantee_id: disclose(verifier_id),
    shared_encryption_key: shared_key,
    threshold: 0 as Uint<64>,  // Not used for employment disclosures
    created_at: current_timestamp,
    last_updated: current_timestamp,
    permission_type: permission_type,
    expires_at: expiration
  };

  // Store authorization on public ledger
  disclosure_authorizations.insert(disclosure_id, authorization);
}

// Grant audit disclosure to auditor (compliance checks, pay equity analysis)
// Stores authorization for auditor to access THIS company's payroll data using ZKML
// NOTE: Actual analysis happens OFF-CHAIN with ZKML proofs (python/ezkl)
// NOTE: Only this contract's company can grant audit disclosure (enforced at API layer)
export circuit grant_audit_disclosure(
  auditor_id: Bytes<32>,
  expires_in: Uint<32>
): [] {
  // No company verification needed - this contract IS the company

  // Generate unique disclosure ID
  const permission_type = PC_PERMISSION_TYPE_AUDIT();
  const disclosure_id = PC_generate_disclosure_id(
    company_id,  // This contract's company ID
    disclose(auditor_id),
    permission_type
  );

  // Generate shared encryption key
  const shared_key = PC_generate_shared_disclosure_key(
    company_id,  // This contract's company ID
    disclose(auditor_id),
    permission_type
  );

  // Calculate expiration timestamp
  const expiration = (disclose(expires_in) == 0 as Uint<32>) ?
    0 as Uint<32> :
    (current_timestamp + disclose(expires_in)) as Uint<32>;

  // Create authorization
  const authorization = PC_DisclosureAuthorization {
    grantor_id: company_id,  // This contract's company ID
    grantee_id: disclose(auditor_id),
    shared_encryption_key: shared_key,
    threshold: 0 as Uint<64>,  // Not used for audit disclosures
    created_at: current_timestamp,
    last_updated: current_timestamp,
    permission_type: permission_type,
    expires_at: expiration
  };

  // Store authorization on public ledger
  disclosure_authorizations.insert(disclosure_id, authorization);
}

// Revoke disclosure authorization
// Allows employee to revoke lender's access to payment history
export circuit revoke_disclosure(
  grantor_id: Bytes<32>,
  grantee_id: Bytes<32>,
  permission_type: Uint<8>
): [] {
  // Generate disclosure ID (disclose permission_type as it's not sensitive)
  const disclosure_id = PC_generate_disclosure_id(
    disclose(grantor_id),
    disclose(grantee_id),
    disclose(permission_type)
  );

  // Verify disclosure exists
  assert(disclosure_authorizations.member(disclosure_id), "Disclosure not found");
  const auth = disclosure_authorizations.lookup(disclosure_id);

  // Verify caller is the grantor (employee who granted access)
  assert(auth.grantor_id == disclose(grantor_id), "Only grantor can revoke");

  // Remove authorization from ledger
  disclosure_authorizations.remove(disclosure_id);

  // Remove shared payment history
  if (shared_payment_history.member(disclosure_id)) {
    shared_payment_history.remove(disclosure_id);
  }
}

// ========================================
// EMPLOYMENT STATUS MANAGEMENT
// ========================================

// Update employee's employment status (company only)
// Allows THIS company to mark employee as active, inactive, terminated, or on leave
// NOTE: Only this contract's company can update status (enforced at API layer)
export circuit update_employment_status(
  employee_id: Bytes<32>,
  new_status: Uint<8>
): [] {
  // Verify employee exists
  assert(employee_accounts.member(disclose(employee_id)), "Employee not found");

  // Generate employment record ID
  const employment_record_id = PC_generate_employment_record_id(
    company_id,  // This contract's company ID
    disclose(employee_id)
  );

  // Verify employment record exists
  assert(employment_records.member(employment_record_id), "Employment record not found");

  // Get existing record
  const existing_record = employment_records.lookup(employment_record_id);

  // Verify record belongs to this company (sanity check)
  assert(existing_record.company_id == company_id, "Employment record mismatch");

  // Update record with new status
  const updated_record = PC_EmploymentRecord {
    company_id: existing_record.company_id,
    employee_id: existing_record.employee_id,
    status: disclose(new_status),
    hire_date: existing_record.hire_date,
    last_updated: current_timestamp
  };

  employment_records.insert(employment_record_id, updated_record);
}

// Verify employment status for disclosure (grantee can check)
// Returns 1 if employee is actively employed at THIS company, 0 otherwise
// NOTE: Verifies employment at this contract's company
export circuit verify_employment(
  employee_id: Bytes<32>,
  verifier_id: Bytes<32>
): Bytes<1> {
  // 1. Check disclosure authorization exists and is valid
  const permission_type = PC_PERMISSION_TYPE_EMPLOYMENT();
  const disclosure_id = PC_generate_disclosure_id(
    disclose(employee_id),
    disclose(verifier_id),
    permission_type
  );

  assert(disclosure_authorizations.member(disclosure_id), "No disclosure permission");
  const auth = disclosure_authorizations.lookup(disclosure_id);

  // Verify caller is the authorized verifier
  assert(auth.grantee_id == disclose(verifier_id), "Not authorized verifier");

  // Check authorization hasn't expired
  assert(
    auth.expires_at == (0 as Uint<32>) || auth.expires_at > current_timestamp,
    "Authorization expired"
  );

  // 2. Get employment record for THIS company
  const employment_record_id = PC_generate_employment_record_id(
    company_id,  // This contract's company ID
    disclose(employee_id)
  );

  // If no employment record exists, return 0 (not employed)
  if (!employment_records.member(employment_record_id)) {
    return pad(1, "\x00");
  }

  const employment_record = employment_records.lookup(employment_record_id);

  // 3. Check if status is ACTIVE
  const is_active = employment_record.status == PC_EMPLOYMENT_STATUS_ACTIVE();

  if (is_active) {
    return pad(1, "\x01");
  } else {
    return pad(1, "\x00");
  }
}

// ========================================
// RECURRING PAYMENTS
// ========================================

// Create recurring payment schedule for automated payroll
// Parameters:
//   employee_id: Employee receiving payments (must be registered)
//   amount: Payment amount (encrypted with employee key)
//   frequency: 0=weekly, 1=bi-weekly, 2=monthly
//   start_date: Unix timestamp when payments begin (>= current_timestamp)
//   end_date: Unix timestamp when payments end (0 = never expires)
// NOTE: Only company can create (enforced at API layer)
export circuit create_recurring_payment(
  employee_id: Bytes<32>,
  amount: Uint<64>,
  frequency: Uint<8>,
  start_date: Uint<32>,
  end_date: Uint<32>
): [] {
  // Verify employee exists
  assert(employee_accounts.member(disclose(employee_id)), "Employee not found");

  // Verify amount is positive
  assert(disclose(amount) > 0 as Uint<64>, "Amount must be positive");

  // Verify frequency is valid (0=weekly, 1=bi-weekly, 2=monthly)
  assert(
    disclose(frequency) == PC_FREQUENCY_WEEKLY() ||
    disclose(frequency) == PC_FREQUENCY_BIWEEKLY() ||
    disclose(frequency) == PC_FREQUENCY_MONTHLY(),
    "Invalid frequency"
  );

  // Verify start_date is in the future (or current)
  assert(disclose(start_date) >= current_timestamp, "Start date must be in the future");

  // Verify end_date is after start_date (if set)
  if (disclose(end_date) > 0 as Uint<32>) {
    assert(disclose(end_date) > disclose(start_date), "End date must be after start date");
  }

  // Generate employee encryption key
  const employee_key = generate_balance_key(employee_id);

  // Encrypt payment amount with employee key (for privacy)
  const encrypted_amount = encrypt_balance(disclose(amount), employee_key);


  // Generate unique recurring payment ID
  const recurring_payment_id = PC_generate_recurring_payment_id(
    company_id,
    disclose(employee_id),
    current_timestamp
  );

  // Calculate first next_payment_date based on start_date and frequency
  const next_payment_date = PC_calculate_next_payment_date(
    disclose(start_date),
    disclose(frequency)
  );

  // Create recurring payment record
  const recurring_payment = PC_RecurringPayment {
    recurring_payment_id: recurring_payment_id,
    company_id: company_id,
    employee_id: disclose(employee_id),
    encrypted_amount: encrypted_amount,
    frequency: disclose(frequency),
    start_date: disclose(start_date),
    end_date: disclose(end_date),
    next_payment_date: next_payment_date,
    status: PC_RECURRING_STATUS_ACTIVE(),
    created_at: current_timestamp,
    last_updated: current_timestamp
  };

  // Store in recurring_payments map
  recurring_payments.insert(recurring_payment_id, recurring_payment);

  // Also store employee_id -> recurring_payment_id mapping for easy lookup
  recurring_payment_by_employee.insert(disclose(employee_id), recurring_payment_id);
}

// Pause a recurring payment (company can pause to temporarily stop payments)
export circuit pause_recurring_payment(recurring_payment_id: Bytes<32>): [] {
  // Verify recurring payment exists
  assert(recurring_payments.member(disclose(recurring_payment_id)), "Recurring payment not found");

  // Get the payment
  const payment = recurring_payments.lookup(disclose(recurring_payment_id));

  // Verify payment is currently ACTIVE
  assert(payment.status == PC_RECURRING_STATUS_ACTIVE(), "Payment must be ACTIVE to pause");

  // Update payment with PAUSED status
  const updated_payment = PC_RecurringPayment {
    recurring_payment_id: payment.recurring_payment_id,
    company_id: payment.company_id,
    employee_id: payment.employee_id,
    encrypted_amount: payment.encrypted_amount,
    frequency: payment.frequency,
    start_date: payment.start_date,
    end_date: payment.end_date,
    next_payment_date: payment.next_payment_date,
    status: PC_RECURRING_STATUS_PAUSED(),
    created_at: payment.created_at,
    last_updated: current_timestamp
  };

  // Update in map
  recurring_payments.insert(disclose(recurring_payment_id), updated_payment);
}

// Resume a paused recurring payment
export circuit resume_recurring_payment(recurring_payment_id: Bytes<32>): [] {
  // Verify recurring payment exists
  assert(recurring_payments.member(disclose(recurring_payment_id)), "Recurring payment not found");

  // Get the payment
  const payment = recurring_payments.lookup(disclose(recurring_payment_id));

  // Verify payment is currently PAUSED
  assert(payment.status == PC_RECURRING_STATUS_PAUSED(), "Payment must be PAUSED to resume");

  // Recalculate next_payment_date from current_timestamp
  const new_next_payment_date = PC_calculate_next_payment_date(
    current_timestamp,
    payment.frequency
  );

  // Update payment with ACTIVE status and new next_payment_date
  const updated_payment = PC_RecurringPayment {
    recurring_payment_id: payment.recurring_payment_id,
    company_id: payment.company_id,
    employee_id: payment.employee_id,
    encrypted_amount: payment.encrypted_amount,
    frequency: payment.frequency,
    start_date: payment.start_date,
    end_date: payment.end_date,
    next_payment_date: new_next_payment_date,
    status: PC_RECURRING_STATUS_ACTIVE(),
    created_at: payment.created_at,
    last_updated: current_timestamp
  };

  // Update in map
  recurring_payments.insert(disclose(recurring_payment_id), updated_payment);
}

// ========================================
// UTILITY FUNCTIONS
// ========================================

export circuit update_timestamp(new_timestamp: Uint<32>): [] {
  assert(new_timestamp > current_timestamp, "Timestamp must be in the future");
  current_timestamp = disclose(new_timestamp);
}
