pragma language_version >= 0.13.0;

import CompactStandardLibrary;
import "../../payroll-commons/PayrollTokens" prefix PT_;
import "../../payroll-commons/PayrollCommons" prefix PC_;

// zkSalaria - Private Payroll System
// Privacy-preserving payroll with real token operations

export { CoinInfo };

// ========================================
// LEDGER STATE (Public)
// ========================================

// Identity registries (hash commitments only - PUBLIC)
export ledger company_accounts: Map<Bytes<32>, Bytes<32>>;
export ledger employee_accounts: Map<Bytes<32>, Bytes<32>>;

// NOTE: Balances now stored in WITNESSES (private), not here!
// See WITNESSES section below for private balance storage

// Token system state (PUBLIC)
export ledger nonce: Bytes<32>;
export ledger token_counter: Counter;
export ledger total_supply: Uint<64>;

// Counters for metrics
export ledger total_companies: Counter;
export ledger total_employees: Counter;
export ledger total_payments: Counter;

// System state
export ledger current_timestamp: Uint<32>;

constructor(initNonce: Bytes<32>) {
  nonce = disclose(initNonce);
  current_timestamp = 1000000 as Uint<32>;
  total_supply = 0 as Uint<64>;
}

// ========================================
// WITNESSES (Private State - Local Only)
// ========================================

// Employee payment history (for ZKML credit scoring)
witness employee_payment_history(employee_id: Bytes<32>): Vector<12, PC_PaymentRecord>;
witness set_employee_payment_history(employee_id: Bytes<32>, history: Vector<12, PC_PaymentRecord>): [];

// Private balance tracking
witness employee_balance(employee_id: Bytes<32>): Uint<64>;
witness set_employee_balance(employee_id: Bytes<32>, balance: Uint<64>): [];

witness company_balance(company_id: Bytes<32>): Uint<64>;
witness set_company_balance(company_id: Bytes<32>, balance: Uint<64>): [];

// ========================================
// TOKEN OPERATIONS (Testing/Bootstrap)
// ========================================

// Mint tokens for testing (will be replaced with real token deposits later)
export circuit mint_tokens(amount: Uint<64>): [] {
  assert(disclose(amount) > 0 as Uint<64>, "Amount must be positive");

  token_counter.increment(1);
  const newNonce = evolveNonce(token_counter, nonce);

  mintToken(
    pad(32, "zksalaria_payroll_token"),
    disclose(amount),
    newNonce,
    left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey())
  );

  total_supply = (total_supply + disclose(amount)) as Uint<64>;
  nonce = newNonce;
}

// ========================================
// COMPANY OPERATIONS
// ========================================

// Register a new company
export circuit register_company(
  company_id: Bytes<32>,
  company_name: Bytes<64>
): [] {
  assert(!company_accounts.member(disclose(company_id)), "Company already exists");

  const company_hash = persistentHash<Vector<2, Bytes<32>>>([
    pad(32, "zksalaria:company:"),
    company_id
  ]);

  company_accounts.insert(disclose(company_id), disclose(company_hash));
  total_companies.increment(1);
}

// Company deposits funds to treasury (mints payroll tokens)
// NOTE: Balance now stored in WITNESS (private), not public ledger
export circuit deposit_company_funds(
  company_id: Bytes<32>,
  amount: Uint<64>
): [] {
  assert(company_accounts.member(disclose(company_id)), "Company not found");
  assert(disclose(amount) > 0 as Uint<64>, "Amount must be positive");

  // Evolve nonce for unique token operation
  token_counter.increment(1);
  const newNonce = evolveNonce(token_counter, nonce);

  // Mint payroll tokens
  mintToken(
    pad(32, "zksalaria_payroll_token"),
    disclose(amount),
    newNonce,
    left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey())
  );

  // Read company balance from WITNESS (private)
  const current_balance = company_balance(company_id);
  const new_balance = (current_balance + disclose(amount)) as Uint<64>;

  // Update company balance in WITNESS (private)
  set_company_balance(company_id, new_balance);

  // Update total supply (public - aggregate metric)
  total_supply = (total_supply + disclose(amount)) as Uint<64>;
  nonce = newNonce;
}

// ========================================
// EMPLOYEE OPERATIONS
// ========================================

// Register a new employee
export circuit add_employee(
  company_id: Bytes<32>,
  employee_id: Bytes<32>
): [] {
  assert(company_accounts.member(disclose(company_id)), "Company not found");
  assert(!employee_accounts.member(disclose(employee_id)), "Employee already exists");

  const employee_hash = persistentHash<Vector<2, Bytes<32>>>([
    pad(32, "zksalaria:employee:"),
    employee_id
  ]);

  employee_accounts.insert(disclose(employee_id), disclose(employee_hash));
  total_employees.increment(1);

  // Initialize empty payment history for new employee
  const empty_history = PC_create_empty_history();
  set_employee_payment_history(employee_id, empty_history);
}

// Employee withdraws earned salary (burns payroll tokens)
// NOTE: Balance now stored in WITNESS (private), not public ledger
export circuit withdraw_employee_salary(
  employee_id: Bytes<32>,
  amount: Uint<64>
): [] {
  // Verify employee exists on public ledger
  assert(employee_accounts.member(disclose(employee_id)), "Employee not found");

  // Read employee balance from WITNESS (private)
  const current_balance = employee_balance(employee_id);
  assert(PT_has_sufficient_balance(current_balance, disclose(amount)), "Insufficient balance");

  // Update employee balance in WITNESS (private)
  const new_balance = (current_balance - disclose(amount)) as Uint<64>;
  set_employee_balance(employee_id, new_balance);

  // Decrease total supply (public - aggregate metric)
  total_supply = (total_supply - disclose(amount)) as Uint<64>;
}

// ========================================
// PAYMENT OPERATIONS
// ========================================

// Process single salary payment (company -> employee)
// NOTE: Balances now stored in WITNESSES (private), not public ledger
export circuit pay_employee(
  company_id: Bytes<32>,
  employee_id: Bytes<32>,
  salary_amount: Uint<64>
): [] {
  // Verify company and employee exist on public ledger
  assert(company_accounts.member(disclose(company_id)), "Company not found");
  assert(employee_accounts.member(disclose(employee_id)), "Employee not found");

  // Read balances from WITNESSES (private)
  const company_bal = company_balance(company_id);
  const employee_bal = employee_balance(employee_id);

  // Verify sufficient balance
  assert(PT_has_sufficient_balance(company_bal, disclose(salary_amount)), "Insufficient company funds");

  // Transfer salary
  const new_balances = PT_transfer_salary(company_bal, employee_bal, disclose(salary_amount));

  // Update balances in WITNESSES (private)
  set_company_balance(company_id, new_balances[0]);
  set_employee_balance(employee_id, new_balances[1]);

  // Read employee payment history from WITNESS
  const history = employee_payment_history(employee_id);

  // Create new payment record
  const new_payment = PC_create_payment_record(
    current_timestamp,
    disclose(salary_amount),
    company_id,
    PC_PAYMENT_TYPE_SALARY()
  );

  // Append to history (shifts old records out)
  const updated_history = PC_append_to_history(history, new_payment);

  // Save updated history to WITNESS
  set_employee_payment_history(employee_id, updated_history);

  // Only public update: increment payment counter (aggregate only)
  total_payments.increment(1);
}

// TODO: Add batch payment processing (requires understanding Compact loop constraints)
// export circuit batch_pay_employees(...)

// ========================================
// UTILITY FUNCTIONS
// ========================================

export circuit update_timestamp(new_timestamp: Uint<32>): [] {
  assert(new_timestamp > current_timestamp, "Timestamp must be in the future");
  current_timestamp = disclose(new_timestamp);
}
