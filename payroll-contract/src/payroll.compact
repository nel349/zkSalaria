pragma language_version >= 0.13.0;

import CompactStandardLibrary;
import "../../payroll-commons/PayrollCommons" prefix PC_;

// zkSalaria - Private Payroll System
// Privacy-preserving payroll with real token operations

export { CoinInfo };

// ========================================
// LEDGER STATE (Public)
// ========================================

// Identity registries (hash commitments only - PUBLIC)
export ledger company_accounts: Map<Bytes<32>, Bytes<32>>;
export ledger employee_accounts: Map<Bytes<32>, Bytes<32>>;

// ENCRYPTED BALANCE SYSTEM (Bank Contract Pattern)
// Balances are encrypted on public ledger, only decryptable with proper keys
export ledger encrypted_company_balances: Map<Bytes<32>, Bytes<32>>;   // company_id -> encrypted_balance
export ledger encrypted_employee_balances: Map<Bytes<32>, Bytes<32>>; // employee_id -> encrypted_balance
export ledger balance_mappings: Map<Bytes<32>, Uint<64>>;             // encrypted_balance -> actual_amount

// Token system state (PUBLIC)
export ledger nonce: Bytes<32>;
export ledger token_counter: Counter;
export ledger total_supply: Uint<64>;

// Counters for metrics
export ledger total_companies: Counter;
export ledger total_employees: Counter;
export ledger total_payments: Counter;

// System state
export ledger current_timestamp: Uint<32>;

constructor(initNonce: Bytes<32>) {
  nonce = disclose(initNonce);
  current_timestamp = 1000000 as Uint<32>;
  total_supply = 0 as Uint<64>;
}

// ========================================
// WITNESSES (Private State - Local Only)
// ========================================

// Employee payment history (for ZKML credit scoring ONLY)
// Balances are now in encrypted ledger, not witnesses
witness employee_payment_history(employee_id: Bytes<32>): Vector<12, PC_PaymentRecord>;
witness set_employee_payment_history(employee_id: Bytes<32>, history: Vector<12, PC_PaymentRecord>): [];

// ========================================
// ENCRYPTION HELPERS (Bank Contract Pattern)
// ========================================

// Encrypt balance with participant's key (hash-based encryption)
pure circuit encrypt_balance(balance: Uint<64>, encryption_key: Bytes<32>): Bytes<32> {
  // Hash balance with key for deterministic encryption
  // In production, would use AES or similar
  const encrypted = persistentHash<Vector<2, Bytes<32>>>([
    persistentHash<Uint<64>>(balance),
    encryption_key
  ]);
  return encrypted;
}

// Generate encryption key for participant (derived from ID + pin/secret)
pure circuit generate_balance_key(participant_id: Bytes<32>, pin: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<3, Bytes<32>>>([
    pad(32, "zksalaria:balance:"),
    participant_id,
    pin
  ]);
}

// Simplified key generation for testing (no PIN required)
// TODO: Replace with PIN-based auth in production
pure circuit generate_simple_balance_key(participant_id: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<2, Bytes<32>>>([
    pad(32, "zksalaria:balance:"),
    disclose(participant_id)  // Disclosed since IDs are already public on ledger
  ]);
}

// ========================================
// TOKEN OPERATIONS (Testing/Bootstrap)
// ========================================

// Mint tokens for testing (will be replaced with real token deposits later)
export circuit mint_tokens(amount: Uint<64>): [] {
  assert(disclose(amount) > 0 as Uint<64>, "Amount must be positive");

  token_counter.increment(1);
  const newNonce = evolveNonce(token_counter, nonce);

  mintToken(
    pad(32, "zksalaria_payroll_token"),
    disclose(amount),
    newNonce,
    left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey())
  );

  total_supply = (total_supply + disclose(amount)) as Uint<64>;
  nonce = newNonce;
}

// ========================================
// COMPANY OPERATIONS
// ========================================

// Register a new company
export circuit register_company(
  company_id: Bytes<32>,
  company_name: Bytes<64>
): [] {
  assert(!company_accounts.member(disclose(company_id)), "Company already exists");

  const company_hash = persistentHash<Vector<2, Bytes<32>>>([
    pad(32, "zksalaria:company:"),
    company_id
  ]);

  company_accounts.insert(disclose(company_id), disclose(company_hash));
  total_companies.increment(1);
}

// Company deposits funds to treasury (mints payroll tokens)
// NOTE: Balance now ENCRYPTED on ledger (bank contract pattern)
export circuit deposit_company_funds(
  company_id: Bytes<32>,
  amount: Uint<64>
): [] {
  assert(company_accounts.member(disclose(company_id)), "Company not found");
  assert(disclose(amount) > 0 as Uint<64>, "Amount must be positive");

  // Evolve nonce for unique token operation
  token_counter.increment(1);
  const newNonce = evolveNonce(token_counter, nonce);

  // Mint payroll tokens
  mintToken(
    pad(32, "zksalaria_payroll_token"),
    disclose(amount),
    newNonce,
    left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey())
  );

  // Generate encryption key for company
  const company_key = generate_simple_balance_key(company_id);

  // Get current encrypted balance (or 0 if new)
  const current_encrypted = encrypted_company_balances.member(disclose(company_id)) ?
    encrypted_company_balances.lookup(disclose(company_id)) : encrypt_balance(0 as Uint<64>, company_key);

  // Decrypt to get actual amount
  const current_balance = balance_mappings.member(current_encrypted) ?
    balance_mappings.lookup(current_encrypted) : 0 as Uint<64>;

  // Add deposit amount
  const new_balance = (current_balance + disclose(amount)) as Uint<64>;

  // Encrypt new balance
  const new_encrypted = encrypt_balance(new_balance, company_key);

  // Update encrypted balance on ledger
  encrypted_company_balances.insert(disclose(company_id), new_encrypted);

  // Update balance mapping for decryption
  balance_mappings.insert(new_encrypted, new_balance);

  // Update total supply (public - aggregate metric)
  total_supply = (total_supply + disclose(amount)) as Uint<64>;
  nonce = newNonce;
}

// ========================================
// EMPLOYEE OPERATIONS
// ========================================

// Register a new employee
export circuit add_employee(
  company_id: Bytes<32>,
  employee_id: Bytes<32>
): [] {
  assert(company_accounts.member(disclose(company_id)), "Company not found");
  assert(!employee_accounts.member(disclose(employee_id)), "Employee already exists");

  const employee_hash = persistentHash<Vector<2, Bytes<32>>>([
    pad(32, "zksalaria:employee:"),
    employee_id
  ]);

  employee_accounts.insert(disclose(employee_id), disclose(employee_hash));
  total_employees.increment(1);

  // Initialize empty payment history for new employee
  const empty_history = PC_create_empty_history();
  set_employee_payment_history(employee_id, empty_history);
}

// Employee withdraws earned salary (burns payroll tokens)
// NOTE: Balance now ENCRYPTED on ledger (bank contract pattern)
export circuit withdraw_employee_salary(
  employee_id: Bytes<32>,
  amount: Uint<64>
): [] {
  // Verify employee exists on public ledger
  assert(employee_accounts.member(disclose(employee_id)), "Employee not found");
  assert(disclose(amount) > 0 as Uint<64>, "Amount must be positive");

  // Generate encryption key for employee
  const employee_key = generate_simple_balance_key(employee_id);

  // Get current encrypted balance
  assert(encrypted_employee_balances.member(disclose(employee_id)), "Employee has no balance");
  const current_encrypted = encrypted_employee_balances.lookup(disclose(employee_id));

  // Decrypt to get actual amount
  const current_balance = balance_mappings.lookup(current_encrypted);

  // Verify sufficient balance
  assert(current_balance >= disclose(amount), "Insufficient balance");

  // Deduct withdrawal amount
  const new_balance = (current_balance - disclose(amount)) as Uint<64>;

  // Encrypt new balance
  const new_encrypted = encrypt_balance(new_balance, employee_key);

  // Update encrypted balance on ledger
  encrypted_employee_balances.insert(disclose(employee_id), new_encrypted);

  // Update balance mapping for decryption
  balance_mappings.insert(new_encrypted, new_balance);

  // Decrease total supply (public - aggregate metric)
  total_supply = (total_supply - disclose(amount)) as Uint<64>;
}

// ========================================
// PAYMENT OPERATIONS
// ========================================

// Process single salary payment (company -> employee)
// NOTE: Balances now ENCRYPTED on ledger (bank contract pattern)
export circuit pay_employee(
  company_id: Bytes<32>,
  employee_id: Bytes<32>,
  salary_amount: Uint<64>
): [] {
  // Verify company and employee exist on public ledger
  assert(company_accounts.member(disclose(company_id)), "Company not found");
  assert(employee_accounts.member(disclose(employee_id)), "Employee not found");
  assert(disclose(salary_amount) > 0 as Uint<64>, "Amount must be positive");

  // Generate encryption keys for both parties
  const company_key = generate_simple_balance_key(company_id);
  const employee_key = generate_simple_balance_key(employee_id);

  // Decrypt company balance
  assert(encrypted_company_balances.member(disclose(company_id)), "Company has no balance");
  const company_encrypted = encrypted_company_balances.lookup(disclose(company_id));
  const company_balance = balance_mappings.lookup(company_encrypted);

  // Verify sufficient balance
  assert(company_balance >= disclose(salary_amount), "Insufficient company funds");

  // Decrypt employee balance (or initialize to 0 if new)
  const employee_encrypted = encrypted_employee_balances.member(disclose(employee_id)) ?
    encrypted_employee_balances.lookup(disclose(employee_id)) : encrypt_balance(0 as Uint<64>, employee_key);
  const employee_balance = balance_mappings.member(employee_encrypted) ?
    balance_mappings.lookup(employee_encrypted) : 0 as Uint<64>;

  // Perform transfer: company pays, employee receives
  const new_company_balance = (company_balance - disclose(salary_amount)) as Uint<64>;
  const new_employee_balance = (employee_balance + disclose(salary_amount)) as Uint<64>;

  // Re-encrypt both balances
  const new_company_encrypted = encrypt_balance(new_company_balance, company_key);
  const new_employee_encrypted = encrypt_balance(new_employee_balance, employee_key);

  // Update encrypted balances on ledger
  encrypted_company_balances.insert(disclose(company_id), new_company_encrypted);
  encrypted_employee_balances.insert(disclose(employee_id), new_employee_encrypted);

  // Update balance mappings for decryption
  balance_mappings.insert(new_company_encrypted, new_company_balance);
  balance_mappings.insert(new_employee_encrypted, new_employee_balance);

  // Read employee payment history from WITNESS (for ZKML tracking)
  const history = employee_payment_history(employee_id);

  // Create new payment record
  const new_payment = PC_create_payment_record(
    current_timestamp,
    disclose(salary_amount),
    company_id,
    PC_PAYMENT_TYPE_SALARY()
  );

  // Append to history (shifts old records out)
  const updated_history = PC_append_to_history(history, new_payment);

  // Save updated history to WITNESS (ZKML data only)
  set_employee_payment_history(employee_id, updated_history);

  // Only public update: increment payment counter (aggregate only)
  total_payments.increment(1);
}

// TODO: Add batch payment processing (requires understanding Compact loop constraints)
// export circuit batch_pay_employees(...)

// ========================================
// UTILITY FUNCTIONS
// ========================================

export circuit update_timestamp(new_timestamp: Uint<32>): [] {
  assert(new_timestamp > current_timestamp, "Timestamp must be in the future");
  current_timestamp = disclose(new_timestamp);
}
