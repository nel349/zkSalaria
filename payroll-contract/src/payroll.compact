pragma language_version >= 0.13.0;

import CompactStandardLibrary;
import "../../payroll-commons/PayrollCommons" prefix PC_;

// zkSalaria - Private Payroll System
// Privacy-preserving payroll with real token operations

export { CoinInfo };

// ========================================
// LEDGER STATE (Public)
// ========================================

// Identity registries (hash commitments only - PUBLIC)
export ledger company_accounts: Map<Bytes<32>, Bytes<32>>;
export ledger employee_accounts: Map<Bytes<32>, Bytes<32>>;

// ENCRYPTED BALANCE SYSTEM (Bank Contract Pattern)
// Balances are encrypted on public ledger, only decryptable with proper keys
export ledger encrypted_company_balances: Map<Bytes<32>, Bytes<32>>;   // company_id -> encrypted_balance
export ledger encrypted_employee_balances: Map<Bytes<32>, Bytes<32>>; // employee_id -> encrypted_balance
export ledger balance_mappings: Map<Bytes<32>, Uint<64>>;             // encrypted_balance -> actual_amount

// Token system state (PUBLIC)
export ledger nonce: Bytes<32>;
export ledger token_counter: Counter;
export ledger total_supply: Uint<64>;

// Counters for metrics
export ledger total_companies: Counter;
export ledger total_employees: Counter;
export ledger total_payments: Counter;

// System state
export ledger current_timestamp: Uint<32>;

// Payment history on ledger (for ZKML credit scoring)
// Stored on public ledger so company can write when paying employee
// NOTE: Following bank.compact pattern - history on ledger, not witnesses
export ledger employee_payment_history: Map<Bytes<32>, Vector<12, PC_PaymentRecord>>;

// Selective disclosure system (Bank Contract Pattern)
// Stores disclosure authorizations and shared keys on public ledger
export ledger disclosure_authorizations: Map<Bytes<32>, PC_DisclosureAuthorization>; // disclosure_id -> authorization
export ledger shared_payment_history: Map<Bytes<32>, Bytes<32>>;  // disclosure_id -> encrypted_history

// Employment status tracking (independent of payment history)
// Key: hash(company_id + employee_id)
export ledger employment_records: Map<Bytes<32>, PC_EmploymentRecord>;

constructor(initNonce: Bytes<32>) {
  nonce = disclose(initNonce);
  current_timestamp = 1000000 as Uint<32>;
  total_supply = 0 as Uint<64>;
}

// ========================================
// ENCRYPTION HELPERS (Bank Contract Pattern)
// ========================================

// Encrypt balance with participant's key (hash-based encryption)
pure circuit encrypt_balance(balance: Uint<64>, encryption_key: Bytes<32>): Bytes<32> {
  // Hash balance with key for deterministic encryption
  // In production, would use AES or similar
  const encrypted = persistentHash<Vector<2, Bytes<32>>>([
    persistentHash<Uint<64>>(balance),
    encryption_key
  ]);
  return encrypted;
}

// Generate encryption key for participant (derived from participant ID)
// NOTE: No PIN needed - authentication happens at API layer (company/employee login)
// Smart contract only verifies: company/employee exists on ledger
pure circuit generate_balance_key(participant_id: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<2, Bytes<32>>>([
    pad(32, "zksalaria:balance:"),
    disclose(participant_id)  // Disclosed since IDs are already public on ledger
  ]);
}

// ========================================
// TOKEN OPERATIONS (Testing/Bootstrap)
// ========================================

// Mint tokens for testing (will be replaced with real token deposits later)
export circuit mint_tokens(amount: Uint<64>): [] {
  assert(disclose(amount) > 0 as Uint<64>, "Amount must be positive");

  token_counter.increment(1);
  const newNonce = evolveNonce(token_counter, nonce);

  mintToken(
    pad(32, "zksalaria_payroll_token"),
    disclose(amount),
    newNonce,
    left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey())
  );

  total_supply = (total_supply + disclose(amount)) as Uint<64>;
  nonce = newNonce;
}

// ========================================
// COMPANY OPERATIONS
// ========================================

// Register a new company
export circuit register_company(
  company_id: Bytes<32>,
  company_name: Bytes<64>
): [] {
  assert(!company_accounts.member(disclose(company_id)), "Company already exists");

  const company_hash = persistentHash<Vector<2, Bytes<32>>>([
    pad(32, "zksalaria:company:"),
    company_id
  ]);

  company_accounts.insert(disclose(company_id), disclose(company_hash));
  total_companies.increment(1);
}

// Company deposits funds to treasury (mints payroll tokens)
// NOTE: Balance now ENCRYPTED on ledger (bank contract pattern)
export circuit deposit_company_funds(
  company_id: Bytes<32>,
  amount: Uint<64>
): [] {
  assert(company_accounts.member(disclose(company_id)), "Company not found");
  assert(disclose(amount) > 0 as Uint<64>, "Amount must be positive");

  // Evolve nonce for unique token operation
  token_counter.increment(1);
  const newNonce = evolveNonce(token_counter, nonce);

  // Mint payroll tokens
  mintToken(
    pad(32, "zksalaria_payroll_token"),
    disclose(amount),
    newNonce,
    left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey())
  );

  // Generate encryption key for company
  const company_key = generate_balance_key(company_id);

  // Get current encrypted balance (or 0 if new)
  const current_encrypted = encrypted_company_balances.member(disclose(company_id)) ?
    encrypted_company_balances.lookup(disclose(company_id)) : encrypt_balance(0 as Uint<64>, company_key);

  // Decrypt to get actual amount
  const current_balance = balance_mappings.member(current_encrypted) ?
    balance_mappings.lookup(current_encrypted) : 0 as Uint<64>;

  // Add deposit amount
  const new_balance = (current_balance + disclose(amount)) as Uint<64>;

  // Encrypt new balance
  const new_encrypted = encrypt_balance(new_balance, company_key);

  // Update encrypted balance on ledger
  encrypted_company_balances.insert(disclose(company_id), new_encrypted);

  // Update balance mapping for decryption
  balance_mappings.insert(new_encrypted, new_balance);

  // Update total supply (public - aggregate metric)
  total_supply = (total_supply + disclose(amount)) as Uint<64>;
  nonce = newNonce;
}

// ========================================
// EMPLOYEE OPERATIONS
// ========================================

// Register a new employee
export circuit add_employee(
  company_id: Bytes<32>,
  employee_id: Bytes<32>
): [] {
  assert(company_accounts.member(disclose(company_id)), "Company not found");
  assert(!employee_accounts.member(disclose(employee_id)), "Employee already exists");

  const employee_hash = persistentHash<Vector<2, Bytes<32>>>([
    pad(32, "zksalaria:employee:"),
    employee_id
  ]);

  employee_accounts.insert(disclose(employee_id), disclose(employee_hash));
  total_employees.increment(1);

  // Initialize empty payment history on ledger for new employee
  const empty_history = PC_create_empty_history();
  employee_payment_history.insert(disclose(employee_id), empty_history);

  // Create employment record with active status
  const employment_record_id = PC_generate_employment_record_id(
    disclose(company_id),
    disclose(employee_id)
  );

  const employment_record = PC_EmploymentRecord {
    company_id: disclose(company_id),
    employee_id: disclose(employee_id),
    status: PC_EMPLOYMENT_STATUS_ACTIVE(),
    hire_date: current_timestamp,
    last_updated: current_timestamp
  };

  employment_records.insert(employment_record_id, employment_record);
}

// Employee withdraws earned salary (burns payroll tokens)
// NOTE: Balance now ENCRYPTED on ledger (bank contract pattern)
export circuit withdraw_employee_salary(
  employee_id: Bytes<32>,
  amount: Uint<64>
): [] {
  // Verify employee exists on public ledger
  assert(employee_accounts.member(disclose(employee_id)), "Employee not found");
  assert(disclose(amount) > 0 as Uint<64>, "Amount must be positive");

  // Generate encryption key for employee
  const employee_key = generate_balance_key(employee_id);

  // Get current encrypted balance
  assert(encrypted_employee_balances.member(disclose(employee_id)), "Employee has no balance");
  const current_encrypted = encrypted_employee_balances.lookup(disclose(employee_id));

  // Decrypt to get actual amount
  const current_balance = balance_mappings.lookup(current_encrypted);

  // Verify sufficient balance
  assert(current_balance >= disclose(amount), "Insufficient balance");

  // Deduct withdrawal amount
  const new_balance = (current_balance - disclose(amount)) as Uint<64>;

  // Encrypt new balance
  const new_encrypted = encrypt_balance(new_balance, employee_key);

  // Update encrypted balance on ledger
  encrypted_employee_balances.insert(disclose(employee_id), new_encrypted);

  // Update balance mapping for decryption
  balance_mappings.insert(new_encrypted, new_balance);

  // Decrease total supply (public - aggregate metric)
  total_supply = (total_supply - disclose(amount)) as Uint<64>;
}

// ========================================
// PAYMENT OPERATIONS
// ========================================

// Process single salary payment (company -> employee)
// NOTE: Balances now ENCRYPTED on ledger (bank contract pattern)
export circuit pay_employee(
  company_id: Bytes<32>,
  employee_id: Bytes<32>,
  salary_amount: Uint<64>
): [] {
  // Verify company and employee exist on public ledger
  assert(company_accounts.member(disclose(company_id)), "Company not found");
  assert(employee_accounts.member(disclose(employee_id)), "Employee not found");
  assert(disclose(salary_amount) > 0 as Uint<64>, "Amount must be positive");

  // Generate encryption keys for both parties
  const company_key = generate_balance_key(company_id);
  const employee_key = generate_balance_key(employee_id);

  // Decrypt company balance
  assert(encrypted_company_balances.member(disclose(company_id)), "Company has no balance");
  const company_encrypted = encrypted_company_balances.lookup(disclose(company_id));
  const company_balance = balance_mappings.lookup(company_encrypted);

  // Verify sufficient balance
  assert(company_balance >= disclose(salary_amount), "Insufficient company funds");

  // Decrypt employee balance (or initialize to 0 if new)
  const employee_encrypted = encrypted_employee_balances.member(disclose(employee_id)) ?
    encrypted_employee_balances.lookup(disclose(employee_id)) : encrypt_balance(0 as Uint<64>, employee_key);
  const employee_balance = balance_mappings.member(employee_encrypted) ?
    balance_mappings.lookup(employee_encrypted) : 0 as Uint<64>;

  // Perform transfer: company pays, employee receives
  const new_company_balance = (company_balance - disclose(salary_amount)) as Uint<64>;
  const new_employee_balance = (employee_balance + disclose(salary_amount)) as Uint<64>;

  // Re-encrypt both balances
  const new_company_encrypted = encrypt_balance(new_company_balance, company_key);
  const new_employee_encrypted = encrypt_balance(new_employee_balance, employee_key);

  // Update encrypted balances on ledger
  encrypted_company_balances.insert(disclose(company_id), new_company_encrypted);
  encrypted_employee_balances.insert(disclose(employee_id), new_employee_encrypted);

  // Update balance mappings for decryption
  balance_mappings.insert(new_company_encrypted, new_company_balance);
  balance_mappings.insert(new_employee_encrypted, new_employee_balance);

  // Read employee payment history from LEDGER (for ZKML tracking)
  // NOTE: Now stored on ledger so company can update it when paying
  const history = employee_payment_history.lookup(disclose(employee_id));

  // Encrypt payment amount with employee's key (privacy - only employee can decrypt for ZKML)
  const encrypted_payment_amount = encrypt_balance(disclose(salary_amount), employee_key);

  // Add encrypted amount to balance_mappings for decryption (bank.compact pattern)
  // This allows employee (and authorized parties with disclosure) to decrypt amounts
  balance_mappings.insert(encrypted_payment_amount, disclose(salary_amount));

  // Create new payment record (with ENCRYPTED amount for privacy)
  const new_payment = PC_create_payment_record(
    current_timestamp,
    encrypted_payment_amount,  // Encrypted amount (not plain text!)
    disclose(company_id),  // Company ID already disclosed for account check
    PC_PAYMENT_TYPE_SALARY()
  );

  // Append to history (shifts old records out)
  const updated_history = PC_append_to_history(history, new_payment);

  // Save updated history to LEDGER (ZKML data, accessible to employee for credit scoring)
  employee_payment_history.insert(disclose(employee_id), updated_history);

  // Only public update: increment payment counter (aggregate only)
  total_payments.increment(1);
}

// TODO: Add batch payment processing (requires understanding Compact loop constraints)
// export circuit batch_pay_employees(...)

// ========================================
// SELECTIVE DISCLOSURE CIRCUITS
// ========================================

// Grant income disclosure to lender/verifier
// Employee grants permission for lender to verify income using ZKML
// NOTE: Actual verification happens OFF-CHAIN with ZK proofs (EZKL)
// This circuit just stores the authorization on ledger
export circuit grant_income_disclosure(
  employee_id: Bytes<32>,
  lender_id: Bytes<32>,
  min_threshold: Uint<64>,
  expires_in: Uint<32>  // 0 = never expires, >0 = seconds until expiration
): [] {
  // Verify employee exists on public ledger
  assert(employee_accounts.member(disclose(employee_id)), "Employee not found");

  // Generate unique disclosure ID
  const permission_type = PC_PERMISSION_TYPE_INCOME_RANGE();
  const disclosure_id = PC_generate_disclosure_id(
    disclose(employee_id),
    disclose(lender_id),
    permission_type
  );

  // Generate shared encryption key (stored on ledger for both parties)
  const shared_key = PC_generate_shared_disclosure_key(
    disclose(employee_id),
    disclose(lender_id),
    permission_type
  );

  // Calculate expiration timestamp (disclose expires_in as it's not sensitive)
  const expiration = (disclose(expires_in) == 0 as Uint<32>) ?
    0 as Uint<32> :
    (current_timestamp + disclose(expires_in)) as Uint<32>;

  // Create disclosure authorization
  const authorization = PC_DisclosureAuthorization {
    grantor_id: disclose(employee_id),
    grantee_id: disclose(lender_id),
    shared_encryption_key: shared_key,
    threshold: disclose(min_threshold),
    created_at: current_timestamp,
    last_updated: current_timestamp,
    permission_type: permission_type,
    expires_at: expiration
  };

  // Store authorization on public ledger
  disclosure_authorizations.insert(disclosure_id, authorization);

  // Read employee payment history from ledger
  const payment_history = employee_payment_history.lookup(disclose(employee_id));

  // Encrypt payment history with shared key for grantee access
  const history_hash = persistentHash<Vector<2, Bytes<32>>>([
    persistentHash<Vector<12, PC_PaymentRecord>>(payment_history),
    shared_key
  ]);

  // Store shared encrypted history on ledger
  shared_payment_history.insert(disclosure_id, history_hash);
}

// Grant employment disclosure to verifier (landlord, background check, etc.)
// Stores authorization for verifier to verify employment status using ZKML
// NOTE: Actual verification happens OFF-CHAIN with ZK proofs (EZKL)
export circuit grant_employment_disclosure(
  employee_id: Bytes<32>,
  verifier_id: Bytes<32>,
  company_id: Bytes<32>,
  expires_in: Uint<32>
): [] {
  // Verify employee and company exist on public ledger
  assert(employee_accounts.member(disclose(employee_id)), "Employee not found");
  assert(company_accounts.member(disclose(company_id)), "Company not found");

  // Generate unique disclosure ID
  const permission_type = PC_PERMISSION_TYPE_EMPLOYMENT();
  const disclosure_id = PC_generate_disclosure_id(
    disclose(employee_id),
    disclose(verifier_id),
    permission_type
  );

  // Generate shared encryption key
  const shared_key = PC_generate_shared_disclosure_key(
    disclose(employee_id),
    disclose(verifier_id),
    permission_type
  );

  // Calculate expiration timestamp
  const expiration = (disclose(expires_in) == 0 as Uint<32>) ?
    0 as Uint<32> :
    (current_timestamp + disclose(expires_in)) as Uint<32>;

  // Create authorization (company_id stored separately if needed)
  const authorization = PC_DisclosureAuthorization {
    grantor_id: disclose(employee_id),
    grantee_id: disclose(verifier_id),
    shared_encryption_key: shared_key,
    threshold: 0 as Uint<64>,  // Not used for employment disclosures
    created_at: current_timestamp,
    last_updated: current_timestamp,
    permission_type: permission_type,
    expires_at: expiration
  };

  // Store authorization on public ledger
  disclosure_authorizations.insert(disclosure_id, authorization);
}

// Grant audit disclosure to auditor (compliance checks, pay equity analysis)
// Stores authorization for auditor to access company payroll data using ZKML
// NOTE: Actual analysis happens OFF-CHAIN with ZKML proofs (python/ezkl)
export circuit grant_audit_disclosure(
  company_id: Bytes<32>,
  auditor_id: Bytes<32>,
  expires_in: Uint<32>
): [] {
  // Verify company exists on public ledger
  assert(company_accounts.member(disclose(company_id)), "Company not found");

  // Generate unique disclosure ID
  const permission_type = PC_PERMISSION_TYPE_AUDIT();
  const disclosure_id = PC_generate_disclosure_id(
    disclose(company_id),
    disclose(auditor_id),
    permission_type
  );

  // Generate shared encryption key
  const shared_key = PC_generate_shared_disclosure_key(
    disclose(company_id),
    disclose(auditor_id),
    permission_type
  );

  // Calculate expiration timestamp
  const expiration = (disclose(expires_in) == 0 as Uint<32>) ?
    0 as Uint<32> :
    (current_timestamp + disclose(expires_in)) as Uint<32>;

  // Create authorization
  const authorization = PC_DisclosureAuthorization {
    grantor_id: disclose(company_id),
    grantee_id: disclose(auditor_id),
    shared_encryption_key: shared_key,
    threshold: 0 as Uint<64>,  // Not used for audit disclosures
    created_at: current_timestamp,
    last_updated: current_timestamp,
    permission_type: permission_type,
    expires_at: expiration
  };

  // Store authorization on public ledger
  disclosure_authorizations.insert(disclosure_id, authorization);
}

// Revoke disclosure authorization
// Allows employee to revoke lender's access to payment history
export circuit revoke_disclosure(
  grantor_id: Bytes<32>,
  grantee_id: Bytes<32>,
  permission_type: Uint<8>
): [] {
  // Generate disclosure ID (disclose permission_type as it's not sensitive)
  const disclosure_id = PC_generate_disclosure_id(
    disclose(grantor_id),
    disclose(grantee_id),
    disclose(permission_type)
  );

  // Verify disclosure exists
  assert(disclosure_authorizations.member(disclosure_id), "Disclosure not found");
  const auth = disclosure_authorizations.lookup(disclosure_id);

  // Verify caller is the grantor (employee who granted access)
  assert(auth.grantor_id == disclose(grantor_id), "Only grantor can revoke");

  // Remove authorization from ledger
  disclosure_authorizations.remove(disclosure_id);

  // Remove shared payment history
  if (shared_payment_history.member(disclosure_id)) {
    shared_payment_history.remove(disclosure_id);
  }
}

// ========================================
// EMPLOYMENT STATUS MANAGEMENT
// ========================================

// Update employee's employment status (company only)
// Allows company to mark employee as active, inactive, terminated, or on leave
export circuit update_employment_status(
  company_id: Bytes<32>,
  employee_id: Bytes<32>,
  new_status: Uint<8>
): [] {
  // Verify company exists
  assert(company_accounts.member(disclose(company_id)), "Company not found");

  // Verify employee exists
  assert(employee_accounts.member(disclose(employee_id)), "Employee not found");

  // Generate employment record ID
  const employment_record_id = PC_generate_employment_record_id(
    disclose(company_id),
    disclose(employee_id)
  );

  // Verify employment record exists
  assert(employment_records.member(employment_record_id), "Employment record not found");

  // Get existing record
  const existing_record = employment_records.lookup(employment_record_id);

  // Verify caller is the company (only company can update status)
  assert(existing_record.company_id == disclose(company_id), "Only company can update status");

  // Update record with new status
  const updated_record = PC_EmploymentRecord {
    company_id: existing_record.company_id,
    employee_id: existing_record.employee_id,
    status: disclose(new_status),
    hire_date: existing_record.hire_date,
    last_updated: current_timestamp
  };

  employment_records.insert(employment_record_id, updated_record);
}

// Verify employment status for disclosure (grantee can check)
// Returns 1 if employee is actively employed, 0 otherwise
export circuit verify_employment(
  employee_id: Bytes<32>,
  company_id: Bytes<32>,
  verifier_id: Bytes<32>
): Bytes<1> {
  // 1. Check disclosure authorization exists and is valid
  const permission_type = PC_PERMISSION_TYPE_EMPLOYMENT();
  const disclosure_id = PC_generate_disclosure_id(
    disclose(employee_id),
    disclose(verifier_id),
    permission_type
  );

  assert(disclosure_authorizations.member(disclosure_id), "No disclosure permission");
  const auth = disclosure_authorizations.lookup(disclosure_id);

  // Verify caller is the authorized verifier
  assert(auth.grantee_id == disclose(verifier_id), "Not authorized verifier");

  // Check authorization hasn't expired
  assert(
    auth.expires_at == (0 as Uint<32>) || auth.expires_at > current_timestamp,
    "Authorization expired"
  );

  // 2. Get employment record
  const employment_record_id = PC_generate_employment_record_id(
    disclose(company_id),
    disclose(employee_id)
  );

  // If no employment record exists, return 0 (not employed)
  if (!employment_records.member(employment_record_id)) {
    return pad(1, "\x00");
  }

  const employment_record = employment_records.lookup(employment_record_id);

  // 3. Check if status is ACTIVE
  const is_active = employment_record.status == PC_EMPLOYMENT_STATUS_ACTIVE();

  if (is_active) {
    return pad(1, "\x01");
  } else {
    return pad(1, "\x00");
  }
}

// ========================================
// UTILITY FUNCTIONS
// ========================================

export circuit update_timestamp(new_timestamp: Uint<32>): [] {
  assert(new_timestamp > current_timestamp, "Timestamp must be in the future");
  current_timestamp = disclose(new_timestamp);
}
