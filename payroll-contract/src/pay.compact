pragma language_version >= 0.13.0;

import CompactStandardLibrary;
import "../../pay-commons/PaymentCommons" prefix PC_;
import "../../pay-commons/TokenOperations" prefix TO_;

// Privacy-Preserving Payment Gateway Contract with Token Support
// Public ledger stores only hashes and proofs, private data in witnesses

// Privacy-preserving ledger state with token balances
export ledger merchant_accounts: Map<Bytes<32>, Bytes<32>>; // encrypted merchant existence
export ledger subscription_accounts: Map<Bytes<32>, Bytes<32>>; // encrypted subscription existence
export ledger customer_balances: Map<Bytes<32>, Uint<64>>; // customer token balances
export ledger merchant_balances: Map<Bytes<32>, Uint<64>>; // merchant token balances
export ledger locked_balances: Map<Bytes<32>, Uint<64>>; // locked funds for subscriptions
export ledger total_merchants: Counter;
export ledger total_subscriptions: Counter;
export ledger total_supply: Uint<64>; // total tokens in circulation
export ledger current_timestamp: Uint<32>;

// Private state provided through witnesses (payment-specific)
witness merchant_info(merchant_id: Bytes<32>): PC_MerchantInfo;
witness set_merchant_info(merchant_id: Bytes<32>, info: PC_MerchantInfo): [];
witness customer_subscription_count(customer_id: Bytes<32>): Uint<32>;
witness set_customer_subscription_count(customer_id: Bytes<32>, count: Uint<32>): [];
witness subscription_info(subscription_id: Bytes<32>): PC_Subscription;
witness set_subscription_info(subscription_id: Bytes<32>, info: PC_Subscription): [];

// Witness for token operation fee calculations
witness calculate_percentage_fee(amount: Uint<64>, fee_basis_points: Uint<16>): Uint<64>;

constructor() {
  current_timestamp = 1000000 as Uint<32>;
  total_supply = 0 as Uint<64>;
}

// Token Operations - Deposit and Withdrawal

// Customer deposits tokens into the payment gateway
export circuit deposit_customer_funds(
  customer_id: Bytes<32>,
  amount: Uint<64>
): [] {
  // Validate deposit amount
  assert(TO_validate_deposit_amount(amount), "Invalid deposit amount");

  // Get current balance (0 if new customer)
  const current_balance = customer_balances.member(disclose(customer_id)) ?
    customer_balances.lookup(disclose(customer_id)) : 0 as Uint<64>;

  // Calculate new balance
  const new_balance = TO_calculate_deposit(current_balance, disclose(amount));

  // Update customer balance
  customer_balances.insert(disclose(customer_id), disclose(new_balance));

  // Update total supply
  total_supply = disclose((total_supply + amount) as Uint<64>);
}

// Customer withdraws tokens from the payment gateway
export circuit withdraw_customer_funds(
  customer_id: Bytes<32>,
  amount: Uint<64>
): [] {
  // Check customer has account
  assert(customer_balances.member(disclose(customer_id)), "Customer account not found");

  // Get current balance
  const current_balance = customer_balances.lookup(disclose(customer_id));

  // Validate withdrawal
  assert(TO_validate_withdrawal_amount(disclose(amount), current_balance), "Invalid withdrawal amount");

  // Calculate new balance
  const new_balance = TO_calculate_withdrawal(current_balance, disclose(amount));

  // Update customer balance
  customer_balances.insert(disclose(customer_id), disclose(new_balance));

  // Update total supply
  total_supply = disclose((total_supply - amount) as Uint<64>);
}

// Merchant withdraws earned tokens
export circuit withdraw_merchant_earnings(
  merchant_id: Bytes<32>,
  amount: Uint<64>
): [] {
  // Check merchant exists
  assert(merchant_accounts.member(disclose(merchant_id)), "Merchant not found");

  // Get current balance
  const current_balance = merchant_balances.member(disclose(merchant_id)) ?
    merchant_balances.lookup(disclose(merchant_id)) : 0 as Uint<64>;

  // Validate withdrawal
  assert(TO_validate_withdrawal_amount(disclose(amount), current_balance), "Invalid withdrawal amount");

  // Calculate new balance
  const new_balance = TO_calculate_withdrawal(current_balance, disclose(amount));

  // Update merchant balance
  merchant_balances.insert(disclose(merchant_id), disclose(new_balance));

  // Update total supply
  total_supply = disclose((total_supply - amount) as Uint<64>);
}

// Privacy-Preserving Merchant Operations
export circuit register_merchant(
  merchant_id: Bytes<32>,
  business_name: Bytes<64>
): [] {
  // Check merchant doesn't already exist
  assert(!merchant_accounts.member(disclose(merchant_id)), "Merchant already exists");

  // Store encrypted merchant existence on public ledger
  const merchant_hash = PC_hash_merchant_id(merchant_id);
  merchant_accounts.insert(disclose(merchant_id), disclose(merchant_hash));
  total_merchants.increment(1);

  // Store merchant info in private state (witness)
  const merchant_info = PC_MerchantInfo {
    merchant_id: disclose(merchant_id),
    business_name: disclose(business_name),
    tier: PC_MERCHANT_TIER.unverified,
    transaction_count: 0 as Uint<32>,
    total_volume: 0 as Uint<64>,
    created_at: current_timestamp,
    is_active: true
  };

  set_merchant_info(merchant_id, merchant_info);
}

// Privacy-preserving subscription creation
export circuit create_subscription(
  merchant_id: Bytes<32>,
  customer_id: Bytes<32>,
  amount: Uint<64>,
  max_amount: Uint<64>,
  frequency_days: Uint<64>
): Bytes<32> {
  // Verify merchant exists
  assert(merchant_accounts.member(disclose(merchant_id)), "Merchant not found");

  // Generate subscription ID using hash function
  const subscription_id = PC_hash_subscription_id(merchant_id, customer_id, current_timestamp);

  // Check subscription doesn't already exist
  assert(!subscription_accounts.member(disclose(subscription_id)), "Subscription already exists");

  // Create subscription info
  const subscription = PC_Subscription {
    subscription_id: disclose(subscription_id),
    merchant_id: disclose(merchant_id),
    customer_id: disclose(customer_id),
    amount: disclose(amount),
    max_amount: disclose(max_amount),
    frequency_days: disclose(frequency_days as Uint<16>),
    status: PC_SUBSCRIPTION_STATUS.active,
    last_payment: current_timestamp,
    next_payment: current_timestamp + (frequency_days * 86400 as Uint<64>) as Uint<32>,
    payment_count: 0 as Uint<32>
  };

  // Store encrypted subscription existence on public ledger
  const subscription_hash = PC_hash_subscription_id(merchant_id, customer_id, current_timestamp);
  subscription_accounts.insert(disclose(subscription_id), disclose(subscription_hash));
  total_subscriptions.increment(1);

  // Store subscription info in private state
  set_subscription_info(subscription_id, subscription);

  // Update customer subscription count
  const current_count = customer_subscription_count(customer_id);
  set_customer_subscription_count(customer_id, (disclose(current_count) + 1 as Uint<32>) as Uint<32>);

  return disclose(subscription_id);
}

// Privacy-preserving subscription pause
export circuit pause_subscription(
  subscription_id: Bytes<32>,
  customer_id: Bytes<32>
): [] {
  // Verify subscription exists
  assert(subscription_accounts.member(disclose(subscription_id)), "Subscription not found");

  // Get subscription info from private state
  const subscription = subscription_info(subscription_id);

  // Verify customer owns this subscription
  assert(subscription.customer_id == disclose(customer_id), "Unauthorized access");

  // Verify subscription is active
  assert(subscription.status == PC_SUBSCRIPTION_STATUS.active, "Subscription not active");

  // Update subscription status to paused
  const updated_subscription = PC_Subscription {
    subscription_id: subscription.subscription_id,
    merchant_id: subscription.merchant_id,
    customer_id: subscription.customer_id,
    amount: subscription.amount,
    max_amount: subscription.max_amount,
    frequency_days: subscription.frequency_days,
    status: PC_SUBSCRIPTION_STATUS.paused,
    last_payment: subscription.last_payment,
    next_payment: subscription.next_payment,
    payment_count: subscription.payment_count
  };

  // Store updated subscription in private state
  set_subscription_info(subscription_id, updated_subscription);

  // Update customer subscription count (decrease active count)
  const current_count = customer_subscription_count(customer_id);
  const new_count = disclose(current_count) > 0 as Uint<32> ? (disclose(current_count) - 1 as Uint<32>) as Uint<32> : 0 as Uint<32>;
  set_customer_subscription_count(customer_id, new_count);
}

// Privacy-preserving subscription resume
export circuit resume_subscription(
  subscription_id: Bytes<32>,
  customer_id: Bytes<32>
): [] {
  // Verify subscription exists
  assert(subscription_accounts.member(disclose(subscription_id)), "Subscription not found");

  // Get subscription info from private state
  const subscription = subscription_info(subscription_id);

  // Verify customer owns this subscription
  assert(subscription.customer_id == disclose(customer_id), "Unauthorized access");

  // Verify subscription is paused
  assert(subscription.status == PC_SUBSCRIPTION_STATUS.paused, "Subscription not paused");

  // Update subscription status to active
  const updated_subscription = PC_Subscription {
    subscription_id: subscription.subscription_id,
    merchant_id: subscription.merchant_id,
    customer_id: subscription.customer_id,
    amount: subscription.amount,
    max_amount: subscription.max_amount,
    frequency_days: subscription.frequency_days,
    status: PC_SUBSCRIPTION_STATUS.active,
    last_payment: subscription.last_payment,
    next_payment: subscription.next_payment,
    payment_count: subscription.payment_count
  };

  // Store updated subscription in private state
  set_subscription_info(subscription_id, updated_subscription);

  // Update customer subscription count (increase active count)
  const current_count = customer_subscription_count(customer_id);
  set_customer_subscription_count(customer_id, (disclose(current_count) + 1 as Uint<32>) as Uint<32>);
}

// Privacy-preserving subscription cancellation
export circuit cancel_subscription(
  subscription_id: Bytes<32>,
  customer_id: Bytes<32>
): [] {
  // Verify subscription exists
  assert(subscription_accounts.member(disclose(subscription_id)), "Subscription not found");

  // Get subscription info from private state
  const subscription = subscription_info(subscription_id);

  // Verify customer owns this subscription
  assert(subscription.customer_id == disclose(customer_id), "Unauthorized access");

  // Verify subscription is not already cancelled
  assert(subscription.status != PC_SUBSCRIPTION_STATUS.cancelled, "Subscription already cancelled");

  // Update subscription status to cancelled
  const updated_subscription = PC_Subscription {
    subscription_id: subscription.subscription_id,
    merchant_id: subscription.merchant_id,
    customer_id: subscription.customer_id,
    amount: subscription.amount,
    max_amount: subscription.max_amount,
    frequency_days: subscription.frequency_days,
    status: PC_SUBSCRIPTION_STATUS.cancelled,
    last_payment: subscription.last_payment,
    next_payment: subscription.next_payment,
    payment_count: subscription.payment_count
  };

  // Store updated subscription in private state
  set_subscription_info(subscription_id, updated_subscription);

  // Update customer subscription count (decrease active count if was active)
  const was_active = subscription.status == PC_SUBSCRIPTION_STATUS.active;
  const current_count = customer_subscription_count(customer_id);
  const new_count = was_active && disclose(current_count) > 0 as Uint<32> ?
    (disclose(current_count) - 1 as Uint<32>) as Uint<32> : disclose(current_count);
  set_customer_subscription_count(customer_id, new_count);
}

// Privacy-preserving subscription payment processing
export circuit process_subscription_payment(
  subscription_id: Bytes<32>,
  service_proof: Bytes<32>
): [] {
  // Verify subscription exists
  assert(subscription_accounts.member(disclose(subscription_id)), "Subscription not found");

  // Get subscription info from private state
  const subscription = subscription_info(subscription_id);

  // Verify subscription is active
  assert(subscription.status == PC_SUBSCRIPTION_STATUS.active, "Subscription not active");

  // Check if payment is due using PaymentCommons function
  const is_due = PC_is_subscription_due(
    subscription.last_payment,
    subscription.frequency_days,
    current_timestamp
  );
  assert(is_due, "Payment not due yet");

  // Check customer has sufficient balance for payment
  const customer_balance = customer_balances.member(disclose(subscription.customer_id)) ?
    customer_balances.lookup(disclose(subscription.customer_id)) : 0 as Uint<64>;
  assert(TO_validate_balance(customer_balance, subscription.amount), "Insufficient customer balance");

  // Get current merchant balance
  const merchant_balance = merchant_balances.member(disclose(subscription.merchant_id)) ?
    merchant_balances.lookup(disclose(subscription.merchant_id)) : 0 as Uint<64>;

  // Calculate merchant fee (using merchant tier)
  const merchant_data = merchant_info(subscription.merchant_id);
  const fee_basis_points = PC_calculate_fee_basis_points(merchant_data.tier);

  // Calculate percentage-based fee using witness
  const fee_amount = calculate_percentage_fee(subscription.amount, fee_basis_points);

  // Verify fee calculation on-chain
  const fee_valid = TO_verify_fee_calculation(subscription.amount, fee_basis_points, fee_amount);
  assert(fee_valid, "Invalid fee calculation");

  // Calculate net amount after fee
  const net_amount = subscription.amount > fee_amount ? (subscription.amount - fee_amount) as Uint<64> : 0 as Uint<64>;

  // Transfer tokens from customer to merchant
  // Customer pays full subscription amount, merchant receives net amount after fees
  const customer_new_balance = TO_calculate_withdrawal(customer_balance, subscription.amount);
  const merchant_new_balance = TO_calculate_deposit(merchant_balance, net_amount);

  // Update balances on ledger
  customer_balances.insert(disclose(subscription.customer_id), disclose(customer_new_balance));
  merchant_balances.insert(disclose(subscription.merchant_id), disclose(merchant_new_balance));

  // The fee could go to a protocol treasury (for simplicity, we'll reduce total supply)
  total_supply = disclose((total_supply - fee_amount) as Uint<64>);

  // Update subscription with payment processed
  const updated_subscription = PC_Subscription {
    subscription_id: subscription.subscription_id,
    merchant_id: subscription.merchant_id,
    customer_id: subscription.customer_id,
    amount: subscription.amount,
    max_amount: subscription.max_amount,
    frequency_days: subscription.frequency_days,
    status: subscription.status,
    last_payment: current_timestamp,
    next_payment: current_timestamp + (subscription.frequency_days * 86400 as Uint<32>) as Uint<32>,
    payment_count: (subscription.payment_count + 1 as Uint<32>) as Uint<32>
  };

  // Store updated subscription in private state
  set_subscription_info(subscription_id, updated_subscription);

  // Update merchant info (increment transaction count and volume)
  // Note: merchant_data was already fetched earlier for fee calculation
  const updated_merchant_info = PC_MerchantInfo {
    merchant_id: merchant_data.merchant_id,
    business_name: merchant_data.business_name,
    tier: PC_calculate_merchant_tier((merchant_data.transaction_count + 1 as Uint<32>) as Uint<32>),
    transaction_count: (merchant_data.transaction_count + 1 as Uint<32>) as Uint<32>,
    total_volume: (merchant_data.total_volume + subscription.amount) as Uint<64>,
    created_at: merchant_data.created_at,
    is_active: merchant_data.is_active
  };

  set_merchant_info(subscription.merchant_id, updated_merchant_info);
}

// Simple customer subscription count proof
export circuit prove_active_subscriptions_count(
  customer_id: Bytes<32>,
  threshold: Uint<32>
): Boolean {
  // Get customer's private subscription count
  const active_count = customer_subscription_count(customer_id);

  // Return boolean proof without revealing exact count
  return disclose(active_count) >= threshold;
}

// Utility Operations
export circuit update_timestamp(new_timestamp: Uint<32>): [] {
  assert(new_timestamp > current_timestamp, "Timestamp must be in the future");
  current_timestamp = disclose(new_timestamp);
}